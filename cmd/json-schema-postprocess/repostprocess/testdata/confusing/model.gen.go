// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package confusing

import "encoding/json"
import "fmt"
import "reflect"

type CMYKVarient struct {
	// C corresponds to the JSON schema field "c".
	C float64 `json:"c" yaml:"c" mapstructure:"c"`

	// K corresponds to the JSON schema field "k".
	K float64 `json:"k" yaml:"k" mapstructure:"k"`

	// M corresponds to the JSON schema field "m".
	M float64 `json:"m" yaml:"m" mapstructure:"m"`

	// Rice corresponds to the JSON schema field "rice".
	Rice *string `json:"rice,omitempty" yaml:"rice,omitempty" mapstructure:"rice,omitempty"`

	// Y corresponds to the JSON schema field "y".
	Y float64 `json:"y" yaml:"y" mapstructure:"y"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CMYKVarient) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["c"]; raw != nil && !ok {
		return fmt.Errorf("field c in CMYKVarient: required")
	}
	if _, ok := raw["k"]; raw != nil && !ok {
		return fmt.Errorf("field k in CMYKVarient: required")
	}
	if _, ok := raw["m"]; raw != nil && !ok {
		return fmt.Errorf("field m in CMYKVarient: required")
	}
	if _, ok := raw["y"]; raw != nil && !ok {
		return fmt.Errorf("field y in CMYKVarient: required")
	}
	type Plain CMYKVarient
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 1 < plain.C {
		return fmt.Errorf("field %s: must be <= %v", "c", 1)
	}
	if 0 > plain.C {
		return fmt.Errorf("field %s: must be >= %v", "c", 0)
	}
	if 1 < plain.K {
		return fmt.Errorf("field %s: must be <= %v", "k", 1)
	}
	if 0 > plain.K {
		return fmt.Errorf("field %s: must be >= %v", "k", 0)
	}
	if 1 < plain.M {
		return fmt.Errorf("field %s: must be <= %v", "m", 1)
	}
	if 0 > plain.M {
		return fmt.Errorf("field %s: must be >= %v", "m", 0)
	}
	if 1 < plain.Y {
		return fmt.Errorf("field %s: must be <= %v", "y", 1)
	}
	if 0 > plain.Y {
		return fmt.Errorf("field %s: must be >= %v", "y", 0)
	}
	*j = CMYKVarient(plain)
	return nil
}

type CategoricalCow struct {
	// ColorScheme corresponds to the JSON schema field "colorScheme".
	ColorScheme *HorseWord `json:"colorScheme,omitempty" yaml:"colorScheme,omitempty" mapstructure:"colorScheme,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Ices corresponds to the JSON schema field "ices".
	Ices []CategoricalCowIcesElem `json:"ices" yaml:"ices" mapstructure:"ices"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Semantic corresponds to the JSON schema field "semantic".
	Semantic *string `json:"semantic" yaml:"semantic" mapstructure:"semantic"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`
}

type CategoricalCowIcesElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CategoricalCow) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["ices"]; raw != nil && !ok {
		return fmt.Errorf("field ices in CategoricalCow: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in CategoricalCow: required")
	}
	if _, ok := raw["semantic"]; raw != nil && !ok {
		return fmt.Errorf("field semantic in CategoricalCow: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CategoricalCow: required")
	}
	type Plain CategoricalCow
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CategoricalCow(plain)
	return nil
}

type ContinuousHorse struct {
	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Location corresponds to the JSON schema field "location".
	Location *float64 `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Rope corresponds to the JSON schema field "rope".
	Rope ContinuousHorseRope `json:"rope" yaml:"rope" mapstructure:"rope"`

	// Undertone corresponds to the JSON schema field "undertone".
	Undertone *Undertone `json:"undertone,omitempty" yaml:"undertone,omitempty" mapstructure:"undertone,omitempty"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`
}

type ContinuousHorseRope interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContinuousHorse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["rope"]; raw != nil && !ok {
		return fmt.Errorf("field rope in ContinuousHorse: required")
	}
	type Plain ContinuousHorse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Location != nil && 1 < *plain.Location {
		return fmt.Errorf("field %s: must be <= %v", "location", 1)
	}
	if plain.Location != nil && 0 > *plain.Location {
		return fmt.Errorf("field %s: must be >= %v", "location", 0)
	}
	*j = ContinuousHorse(plain)
	return nil
}

type ContinuousScaleCow struct {
	// ColorScheme corresponds to the JSON schema field "colorScheme".
	ColorScheme *HorseWord `json:"colorScheme,omitempty" yaml:"colorScheme,omitempty" mapstructure:"colorScheme,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Ices corresponds to the JSON schema field "ices".
	Ices []ContinuousHorse `json:"ices" yaml:"ices" mapstructure:"ices"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Semantic corresponds to the JSON schema field "semantic".
	Semantic *string `json:"semantic" yaml:"semantic" mapstructure:"semantic"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContinuousScaleCow) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["ices"]; raw != nil && !ok {
		return fmt.Errorf("field ices in ContinuousScaleCow: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ContinuousScaleCow: required")
	}
	if _, ok := raw["semantic"]; raw != nil && !ok {
		return fmt.Errorf("field semantic in ContinuousScaleCow: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ContinuousScaleCow: required")
	}
	type Plain ContinuousScaleCow
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContinuousScaleCow(plain)
	return nil
}

type Cow interface{}

type DiscreteScaleCow struct {
	// ColorScheme corresponds to the JSON schema field "colorScheme".
	ColorScheme *HorseWord `json:"colorScheme,omitempty" yaml:"colorScheme,omitempty" mapstructure:"colorScheme,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Ices corresponds to the JSON schema field "ices".
	Ices []DiscreteScaleCowIcesElem `json:"ices" yaml:"ices" mapstructure:"ices"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Semantic corresponds to the JSON schema field "semantic".
	Semantic *string `json:"semantic" yaml:"semantic" mapstructure:"semantic"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`
}

type DiscreteScaleCowIcesElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DiscreteScaleCow) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["ices"]; raw != nil && !ok {
		return fmt.Errorf("field ices in DiscreteScaleCow: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in DiscreteScaleCow: required")
	}
	if _, ok := raw["semantic"]; raw != nil && !ok {
		return fmt.Errorf("field semantic in DiscreteScaleCow: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DiscreteScaleCow: required")
	}
	type Plain DiscreteScaleCow
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DiscreteScaleCow(plain)
	return nil
}

type HSIVarient struct {
	// H corresponds to the JSON schema field "h".
	H float64 `json:"h" yaml:"h" mapstructure:"h"`

	// I corresponds to the JSON schema field "i".
	I float64 `json:"i" yaml:"i" mapstructure:"i"`

	// Rice corresponds to the JSON schema field "rice".
	Rice *string `json:"rice,omitempty" yaml:"rice,omitempty" mapstructure:"rice,omitempty"`

	// S corresponds to the JSON schema field "s".
	S float64 `json:"s" yaml:"s" mapstructure:"s"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HSIVarient) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["h"]; raw != nil && !ok {
		return fmt.Errorf("field h in HSIVarient: required")
	}
	if _, ok := raw["i"]; raw != nil && !ok {
		return fmt.Errorf("field i in HSIVarient: required")
	}
	if _, ok := raw["s"]; raw != nil && !ok {
		return fmt.Errorf("field s in HSIVarient: required")
	}
	type Plain HSIVarient
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 360 < plain.H {
		return fmt.Errorf("field %s: must be <= %v", "h", 360)
	}
	if 0 > plain.H {
		return fmt.Errorf("field %s: must be >= %v", "h", 0)
	}
	if 1 < plain.I {
		return fmt.Errorf("field %s: must be <= %v", "i", 1)
	}
	if 0 > plain.I {
		return fmt.Errorf("field %s: must be >= %v", "i", 0)
	}
	if 1 < plain.S {
		return fmt.Errorf("field %s: must be <= %v", "s", 1)
	}
	if 0 > plain.S {
		return fmt.Errorf("field %s: must be >= %v", "s", 0)
	}
	*j = HSIVarient(plain)
	return nil
}

type HSLVarient struct {
	// H corresponds to the JSON schema field "h".
	H float64 `json:"h" yaml:"h" mapstructure:"h"`

	// L corresponds to the JSON schema field "l".
	L float64 `json:"l" yaml:"l" mapstructure:"l"`

	// Rice corresponds to the JSON schema field "rice".
	Rice *string `json:"rice,omitempty" yaml:"rice,omitempty" mapstructure:"rice,omitempty"`

	// S corresponds to the JSON schema field "s".
	S float64 `json:"s" yaml:"s" mapstructure:"s"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HSLVarient) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["h"]; raw != nil && !ok {
		return fmt.Errorf("field h in HSLVarient: required")
	}
	if _, ok := raw["l"]; raw != nil && !ok {
		return fmt.Errorf("field l in HSLVarient: required")
	}
	if _, ok := raw["s"]; raw != nil && !ok {
		return fmt.Errorf("field s in HSLVarient: required")
	}
	type Plain HSLVarient
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 360 < plain.H {
		return fmt.Errorf("field %s: must be <= %v", "h", 360)
	}
	if 0 > plain.H {
		return fmt.Errorf("field %s: must be >= %v", "h", 0)
	}
	if 1 < plain.L {
		return fmt.Errorf("field %s: must be <= %v", "l", 1)
	}
	if 0 > plain.L {
		return fmt.Errorf("field %s: must be >= %v", "l", 0)
	}
	if 1 < plain.S {
		return fmt.Errorf("field %s: must be <= %v", "s", 1)
	}
	if 0 > plain.S {
		return fmt.Errorf("field %s: must be >= %v", "s", 0)
	}
	*j = HSLVarient(plain)
	return nil
}

type HSVVarient struct {
	// H corresponds to the JSON schema field "h".
	H float64 `json:"h" yaml:"h" mapstructure:"h"`

	// Rice corresponds to the JSON schema field "rice".
	Rice *string `json:"rice,omitempty" yaml:"rice,omitempty" mapstructure:"rice,omitempty"`

	// S corresponds to the JSON schema field "s".
	S float64 `json:"s" yaml:"s" mapstructure:"s"`

	// V corresponds to the JSON schema field "v".
	V float64 `json:"v" yaml:"v" mapstructure:"v"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HSVVarient) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["h"]; raw != nil && !ok {
		return fmt.Errorf("field h in HSVVarient: required")
	}
	if _, ok := raw["s"]; raw != nil && !ok {
		return fmt.Errorf("field s in HSVVarient: required")
	}
	if _, ok := raw["v"]; raw != nil && !ok {
		return fmt.Errorf("field v in HSVVarient: required")
	}
	type Plain HSVVarient
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 360 < plain.H {
		return fmt.Errorf("field %s: must be <= %v", "h", 360)
	}
	if 0 > plain.H {
		return fmt.Errorf("field %s: must be >= %v", "h", 0)
	}
	if 1 < plain.S {
		return fmt.Errorf("field %s: must be <= %v", "s", 1)
	}
	if 0 > plain.S {
		return fmt.Errorf("field %s: must be >= %v", "s", 0)
	}
	if 1 < plain.V {
		return fmt.Errorf("field %s: must be <= %v", "v", 1)
	}
	if 0 > plain.V {
		return fmt.Errorf("field %s: must be >= %v", "v", 0)
	}
	*j = HSVVarient(plain)
	return nil
}

type Horse interface{}

type HorseConfig struct {
	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Rope corresponds to the JSON schema field "rope".
	Rope HorseConfigRope `json:"rope" yaml:"rope" mapstructure:"rope"`

	// Undertone corresponds to the JSON schema field "undertone".
	Undertone *Undertone `json:"undertone,omitempty" yaml:"undertone,omitempty" mapstructure:"undertone,omitempty"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`
}

type HorseConfigRope interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HorseConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["rope"]; raw != nil && !ok {
		return fmt.Errorf("field rope in HorseConfig: required")
	}
	type Plain HorseConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = HorseConfig(plain)
	return nil
}

type HorseWord string

const HorseWordAchromatic HorseWord = "achromatic"
const HorseWordAnalogous HorseWord = "analogous"
const HorseWordComplementary HorseWord = "complementary"
const HorseWordCustomized HorseWord = "customized"
const HorseWordMonochromatic HorseWord = "monochromatic"
const HorseWordPolychromatic HorseWord = "polychromatic"
const HorseWordSplitComplementary HorseWord = "split-complementary"
const HorseWordTetradic HorseWord = "tetradic"
const HorseWordTriadic HorseWord = "triadic"

var enumValues_HorseWord = []interface{}{
	"monochromatic",
	"complementary",
	"split-complementary",
	"achromatic",
	"analogous",
	"triadic",
	"tetradic",
	"polychromatic",
	"customized",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HorseWord) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_HorseWord {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_HorseWord, v)
	}
	*j = HorseWord(v)
	return nil
}

type LABVarient struct {
	// A corresponds to the JSON schema field "a".
	A float64 `json:"a" yaml:"a" mapstructure:"a"`

	// B corresponds to the JSON schema field "b".
	B float64 `json:"b" yaml:"b" mapstructure:"b"`

	// L corresponds to the JSON schema field "l".
	L float64 `json:"l" yaml:"l" mapstructure:"l"`

	// Rice corresponds to the JSON schema field "rice".
	Rice *string `json:"rice,omitempty" yaml:"rice,omitempty" mapstructure:"rice,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LABVarient) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["a"]; raw != nil && !ok {
		return fmt.Errorf("field a in LABVarient: required")
	}
	if _, ok := raw["b"]; raw != nil && !ok {
		return fmt.Errorf("field b in LABVarient: required")
	}
	if _, ok := raw["l"]; raw != nil && !ok {
		return fmt.Errorf("field l in LABVarient: required")
	}
	type Plain LABVarient
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 98.254 < plain.A {
		return fmt.Errorf("field %s: must be <= %v", "a", 98.254)
	}
	if -86.185 > plain.A {
		return fmt.Errorf("field %s: must be >= %v", "a", -86.185)
	}
	if 94.482 < plain.B {
		return fmt.Errorf("field %s: must be <= %v", "b", 94.482)
	}
	if -107.863 > plain.B {
		return fmt.Errorf("field %s: must be >= %v", "b", -107.863)
	}
	if 100 < plain.L {
		return fmt.Errorf("field %s: must be <= %v", "l", 100)
	}
	if 0 > plain.L {
		return fmt.Errorf("field %s: must be >= %v", "l", 0)
	}
	*j = LABVarient(plain)
	return nil
}

type LCHVarient struct {
	// C corresponds to the JSON schema field "c".
	C float64 `json:"c" yaml:"c" mapstructure:"c"`

	// H corresponds to the JSON schema field "h".
	H float64 `json:"h" yaml:"h" mapstructure:"h"`

	// L corresponds to the JSON schema field "l".
	L float64 `json:"l" yaml:"l" mapstructure:"l"`

	// Rice corresponds to the JSON schema field "rice".
	Rice *string `json:"rice,omitempty" yaml:"rice,omitempty" mapstructure:"rice,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LCHVarient) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["c"]; raw != nil && !ok {
		return fmt.Errorf("field c in LCHVarient: required")
	}
	if _, ok := raw["h"]; raw != nil && !ok {
		return fmt.Errorf("field h in LCHVarient: required")
	}
	if _, ok := raw["l"]; raw != nil && !ok {
		return fmt.Errorf("field l in LCHVarient: required")
	}
	type Plain LCHVarient
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 100 < plain.C {
		return fmt.Errorf("field %s: must be <= %v", "c", 100)
	}
	if 0 > plain.C {
		return fmt.Errorf("field %s: must be >= %v", "c", 0)
	}
	if 360 < plain.H {
		return fmt.Errorf("field %s: must be <= %v", "h", 360)
	}
	if 0 > plain.H {
		return fmt.Errorf("field %s: must be >= %v", "h", 0)
	}
	if 100 < plain.L {
		return fmt.Errorf("field %s: must be <= %v", "l", 100)
	}
	if 0 > plain.L {
		return fmt.Errorf("field %s: must be >= %v", "l", 0)
	}
	*j = LCHVarient(plain)
	return nil
}

type MatrixCow struct {
	// ColorScheme corresponds to the JSON schema field "colorScheme".
	ColorScheme *HorseWord `json:"colorScheme,omitempty" yaml:"colorScheme,omitempty" mapstructure:"colorScheme,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Ices corresponds to the JSON schema field "ices".
	Ices [][]MatrixCowIcesElemElem `json:"ices" yaml:"ices" mapstructure:"ices"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Origin corresponds to the JSON schema field "origin".
	Origin Origin `json:"origin" yaml:"origin" mapstructure:"origin"`

	// Semantic corresponds to the JSON schema field "semantic".
	Semantic *string `json:"semantic" yaml:"semantic" mapstructure:"semantic"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`
}

type MatrixCowIcesElemElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MatrixCow) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["ices"]; raw != nil && !ok {
		return fmt.Errorf("field ices in MatrixCow: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in MatrixCow: required")
	}
	if _, ok := raw["origin"]; raw != nil && !ok {
		return fmt.Errorf("field origin in MatrixCow: required")
	}
	if _, ok := raw["semantic"]; raw != nil && !ok {
		return fmt.Errorf("field semantic in MatrixCow: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in MatrixCow: required")
	}
	type Plain MatrixCow
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MatrixCow(plain)
	return nil
}

type Origin struct {
	// X corresponds to the JSON schema field "x".
	X []OriginXElem `json:"x" yaml:"x" mapstructure:"x"`

	// Y corresponds to the JSON schema field "y".
	Y []OriginYElem `json:"y" yaml:"y" mapstructure:"y"`
}

type OriginXElem interface{}

type OriginYElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Origin) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["x"]; raw != nil && !ok {
		return fmt.Errorf("field x in Origin: required")
	}
	if _, ok := raw["y"]; raw != nil && !ok {
		return fmt.Errorf("field y in Origin: required")
	}
	type Plain Origin
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Origin(plain)
	return nil
}

type RGBAVarient struct {
	// A corresponds to the JSON schema field "a".
	A float64 `json:"a" yaml:"a" mapstructure:"a"`

	// B corresponds to the JSON schema field "b".
	B float64 `json:"b" yaml:"b" mapstructure:"b"`

	// G corresponds to the JSON schema field "g".
	G float64 `json:"g" yaml:"g" mapstructure:"g"`

	// R corresponds to the JSON schema field "r".
	R float64 `json:"r" yaml:"r" mapstructure:"r"`

	// Rice corresponds to the JSON schema field "rice".
	Rice *string `json:"rice,omitempty" yaml:"rice,omitempty" mapstructure:"rice,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RGBAVarient) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["a"]; raw != nil && !ok {
		return fmt.Errorf("field a in RGBAVarient: required")
	}
	if _, ok := raw["b"]; raw != nil && !ok {
		return fmt.Errorf("field b in RGBAVarient: required")
	}
	if _, ok := raw["g"]; raw != nil && !ok {
		return fmt.Errorf("field g in RGBAVarient: required")
	}
	if _, ok := raw["r"]; raw != nil && !ok {
		return fmt.Errorf("field r in RGBAVarient: required")
	}
	type Plain RGBAVarient
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 1 < plain.A {
		return fmt.Errorf("field %s: must be <= %v", "a", 1)
	}
	if 0 > plain.A {
		return fmt.Errorf("field %s: must be >= %v", "a", 0)
	}
	if 255 < plain.B {
		return fmt.Errorf("field %s: must be <= %v", "b", 255)
	}
	if 0 > plain.B {
		return fmt.Errorf("field %s: must be >= %v", "b", 0)
	}
	if 255 < plain.G {
		return fmt.Errorf("field %s: must be <= %v", "g", 255)
	}
	if 0 > plain.G {
		return fmt.Errorf("field %s: must be >= %v", "g", 0)
	}
	if 255 < plain.R {
		return fmt.Errorf("field %s: must be <= %v", "r", 255)
	}
	if 0 > plain.R {
		return fmt.Errorf("field %s: must be >= %v", "r", 0)
	}
	*j = RGBAVarient(plain)
	return nil
}

type RGBVarient struct {
	// B corresponds to the JSON schema field "b".
	B float64 `json:"b" yaml:"b" mapstructure:"b"`

	// G corresponds to the JSON schema field "g".
	G float64 `json:"g" yaml:"g" mapstructure:"g"`

	// R corresponds to the JSON schema field "r".
	R float64 `json:"r" yaml:"r" mapstructure:"r"`

	// Rice corresponds to the JSON schema field "rice".
	Rice *string `json:"rice,omitempty" yaml:"rice,omitempty" mapstructure:"rice,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RGBVarient) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["b"]; raw != nil && !ok {
		return fmt.Errorf("field b in RGBVarient: required")
	}
	if _, ok := raw["g"]; raw != nil && !ok {
		return fmt.Errorf("field g in RGBVarient: required")
	}
	if _, ok := raw["r"]; raw != nil && !ok {
		return fmt.Errorf("field r in RGBVarient: required")
	}
	type Plain RGBVarient
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 255 < plain.B {
		return fmt.Errorf("field %s: must be <= %v", "b", 255)
	}
	if 0 > plain.B {
		return fmt.Errorf("field %s: must be >= %v", "b", 0)
	}
	if 255 < plain.G {
		return fmt.Errorf("field %s: must be <= %v", "g", 255)
	}
	if 0 > plain.G {
		return fmt.Errorf("field %s: must be >= %v", "g", 0)
	}
	if 255 < plain.R {
		return fmt.Errorf("field %s: must be <= %v", "r", 255)
	}
	if 0 > plain.R {
		return fmt.Errorf("field %s: must be >= %v", "r", 0)
	}
	*j = RGBVarient(plain)
	return nil
}

type Tractor struct {
	// BrandName corresponds to the JSON schema field "brandName".
	BrandName string `json:"brandName" yaml:"brandName" mapstructure:"brandName"`

	// Cheeses corresponds to the JSON schema field "cheeses".
	Cheeses []TractorCheesesElem `json:"cheeses" yaml:"cheeses" mapstructure:"cheeses"`
}

type TractorCheesesElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tractor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["brandName"]; raw != nil && !ok {
		return fmt.Errorf("field brandName in Tractor: required")
	}
	if _, ok := raw["cheeses"]; raw != nil && !ok {
		return fmt.Errorf("field cheeses in Tractor: required")
	}
	type Plain Tractor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Tractor(plain)
	return nil
}

type Undertone string

const UndertoneCool Undertone = "cool"
const UndertoneNeutral Undertone = "neutral"
const UndertoneWarm Undertone = "warm"

var enumValues_Undertone = []interface{}{
	"warm",
	"neutral",
	"cool",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Undertone) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Undertone {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Undertone, v)
	}
	*j = Undertone(v)
	return nil
}
