// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package testdata

import "encoding/json"
import "fmt"
import "reflect"

type AssetPack struct {
	// BrandName corresponds to the JSON schema field "brandName".
	BrandName string `json:"brandName" yaml:"brandName" mapstructure:"brandName"`

	// Palettes corresponds to the JSON schema field "palettes".
	Palettes []AssetPackPalettesElem `json:"palettes" yaml:"palettes" mapstructure:"palettes"`
}

type AssetPackPalettesElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AssetPack) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["brandName"]; raw != nil && !ok {
		return fmt.Errorf("field brandName in AssetPack: required")
	}
	if _, ok := raw["palettes"]; raw != nil && !ok {
		return fmt.Errorf("field palettes in AssetPack: required")
	}
	type Plain AssetPack
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AssetPack(plain)
	return nil
}

type CMYKValue struct {
	// C corresponds to the JSON schema field "c".
	C float64 `json:"c" yaml:"c" mapstructure:"c"`

	// K corresponds to the JSON schema field "k".
	K float64 `json:"k" yaml:"k" mapstructure:"k"`

	// M corresponds to the JSON schema field "m".
	M float64 `json:"m" yaml:"m" mapstructure:"m"`

	// Model corresponds to the JSON schema field "model".
	Model *string `json:"model,omitempty" yaml:"model,omitempty" mapstructure:"model,omitempty"`

	// Y corresponds to the JSON schema field "y".
	Y float64 `json:"y" yaml:"y" mapstructure:"y"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CMYKValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["c"]; raw != nil && !ok {
		return fmt.Errorf("field c in CMYKValue: required")
	}
	if _, ok := raw["k"]; raw != nil && !ok {
		return fmt.Errorf("field k in CMYKValue: required")
	}
	if _, ok := raw["m"]; raw != nil && !ok {
		return fmt.Errorf("field m in CMYKValue: required")
	}
	if _, ok := raw["y"]; raw != nil && !ok {
		return fmt.Errorf("field y in CMYKValue: required")
	}
	type Plain CMYKValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 1 < plain.C {
		return fmt.Errorf("field %s: must be <= %v", "c", 1)
	}
	if 0 > plain.C {
		return fmt.Errorf("field %s: must be >= %v", "c", 0)
	}
	if 1 < plain.K {
		return fmt.Errorf("field %s: must be <= %v", "k", 1)
	}
	if 0 > plain.K {
		return fmt.Errorf("field %s: must be >= %v", "k", 0)
	}
	if 1 < plain.M {
		return fmt.Errorf("field %s: must be <= %v", "m", 1)
	}
	if 0 > plain.M {
		return fmt.Errorf("field %s: must be >= %v", "m", 0)
	}
	if 1 < plain.Y {
		return fmt.Errorf("field %s: must be <= %v", "y", 1)
	}
	if 0 > plain.Y {
		return fmt.Errorf("field %s: must be >= %v", "y", 0)
	}
	*j = CMYKValue(plain)
	return nil
}

type CategoricalPalette struct {
	// ColorScheme corresponds to the JSON schema field "colorScheme".
	ColorScheme *ColorSchemeType `json:"colorScheme,omitempty" yaml:"colorScheme,omitempty" mapstructure:"colorScheme,omitempty"`

	// Colors corresponds to the JSON schema field "colors".
	Colors []CategoricalPaletteColorsElem `json:"colors" yaml:"colors" mapstructure:"colors"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Semantic corresponds to the JSON schema field "semantic".
	Semantic *string `json:"semantic" yaml:"semantic" mapstructure:"semantic"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`
}

type CategoricalPaletteColorsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CategoricalPalette) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["colors"]; raw != nil && !ok {
		return fmt.Errorf("field colors in CategoricalPalette: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in CategoricalPalette: required")
	}
	if _, ok := raw["semantic"]; raw != nil && !ok {
		return fmt.Errorf("field semantic in CategoricalPalette: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in CategoricalPalette: required")
	}
	type Plain CategoricalPalette
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CategoricalPalette(plain)
	return nil
}

type Color interface{}

type ColorConfig struct {
	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Undertone corresponds to the JSON schema field "undertone".
	Undertone *Undertone `json:"undertone,omitempty" yaml:"undertone,omitempty" mapstructure:"undertone,omitempty"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value ColorConfigValue `json:"value" yaml:"value" mapstructure:"value"`
}

type ColorConfigValue interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ColorConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in ColorConfig: required")
	}
	type Plain ColorConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ColorConfig(plain)
	return nil
}

type ColorSchemeType string

const ColorSchemeTypeAchromatic ColorSchemeType = "achromatic"
const ColorSchemeTypeAnalogous ColorSchemeType = "analogous"
const ColorSchemeTypeComplementary ColorSchemeType = "complementary"
const ColorSchemeTypeCustomized ColorSchemeType = "customized"
const ColorSchemeTypeMonochromatic ColorSchemeType = "monochromatic"
const ColorSchemeTypePolychromatic ColorSchemeType = "polychromatic"
const ColorSchemeTypeSplitComplementary ColorSchemeType = "split-complementary"
const ColorSchemeTypeTetradic ColorSchemeType = "tetradic"
const ColorSchemeTypeTriadic ColorSchemeType = "triadic"

var enumValues_ColorSchemeType = []interface{}{
	"monochromatic",
	"complementary",
	"split-complementary",
	"achromatic",
	"analogous",
	"triadic",
	"tetradic",
	"polychromatic",
	"customized",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ColorSchemeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ColorSchemeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ColorSchemeType, v)
	}
	*j = ColorSchemeType(v)
	return nil
}

type ContinuousColor struct {
	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Location corresponds to the JSON schema field "location".
	Location *float64 `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Undertone corresponds to the JSON schema field "undertone".
	Undertone *Undertone `json:"undertone,omitempty" yaml:"undertone,omitempty" mapstructure:"undertone,omitempty"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value ContinuousColorValue `json:"value" yaml:"value" mapstructure:"value"`
}

type ContinuousColorValue interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContinuousColor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in ContinuousColor: required")
	}
	type Plain ContinuousColor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Location != nil && 1 < *plain.Location {
		return fmt.Errorf("field %s: must be <= %v", "location", 1)
	}
	if plain.Location != nil && 0 > *plain.Location {
		return fmt.Errorf("field %s: must be >= %v", "location", 0)
	}
	*j = ContinuousColor(plain)
	return nil
}

type ContinuousScalePalette struct {
	// ColorScheme corresponds to the JSON schema field "colorScheme".
	ColorScheme *ColorSchemeType `json:"colorScheme,omitempty" yaml:"colorScheme,omitempty" mapstructure:"colorScheme,omitempty"`

	// Colors corresponds to the JSON schema field "colors".
	Colors []ContinuousColor `json:"colors" yaml:"colors" mapstructure:"colors"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Semantic corresponds to the JSON schema field "semantic".
	Semantic *string `json:"semantic" yaml:"semantic" mapstructure:"semantic"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContinuousScalePalette) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["colors"]; raw != nil && !ok {
		return fmt.Errorf("field colors in ContinuousScalePalette: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ContinuousScalePalette: required")
	}
	if _, ok := raw["semantic"]; raw != nil && !ok {
		return fmt.Errorf("field semantic in ContinuousScalePalette: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ContinuousScalePalette: required")
	}
	type Plain ContinuousScalePalette
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContinuousScalePalette(plain)
	return nil
}

type DiscreteScalePalette struct {
	// ColorScheme corresponds to the JSON schema field "colorScheme".
	ColorScheme *ColorSchemeType `json:"colorScheme,omitempty" yaml:"colorScheme,omitempty" mapstructure:"colorScheme,omitempty"`

	// Colors corresponds to the JSON schema field "colors".
	Colors []DiscreteScalePaletteColorsElem `json:"colors" yaml:"colors" mapstructure:"colors"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Semantic corresponds to the JSON schema field "semantic".
	Semantic *string `json:"semantic" yaml:"semantic" mapstructure:"semantic"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`
}

type DiscreteScalePaletteColorsElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DiscreteScalePalette) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["colors"]; raw != nil && !ok {
		return fmt.Errorf("field colors in DiscreteScalePalette: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in DiscreteScalePalette: required")
	}
	if _, ok := raw["semantic"]; raw != nil && !ok {
		return fmt.Errorf("field semantic in DiscreteScalePalette: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in DiscreteScalePalette: required")
	}
	type Plain DiscreteScalePalette
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DiscreteScalePalette(plain)
	return nil
}

type HSIValue struct {
	// H corresponds to the JSON schema field "h".
	H float64 `json:"h" yaml:"h" mapstructure:"h"`

	// I corresponds to the JSON schema field "i".
	I float64 `json:"i" yaml:"i" mapstructure:"i"`

	// Model corresponds to the JSON schema field "model".
	Model *string `json:"model,omitempty" yaml:"model,omitempty" mapstructure:"model,omitempty"`

	// S corresponds to the JSON schema field "s".
	S float64 `json:"s" yaml:"s" mapstructure:"s"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HSIValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["h"]; raw != nil && !ok {
		return fmt.Errorf("field h in HSIValue: required")
	}
	if _, ok := raw["i"]; raw != nil && !ok {
		return fmt.Errorf("field i in HSIValue: required")
	}
	if _, ok := raw["s"]; raw != nil && !ok {
		return fmt.Errorf("field s in HSIValue: required")
	}
	type Plain HSIValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 360 < plain.H {
		return fmt.Errorf("field %s: must be <= %v", "h", 360)
	}
	if 0 > plain.H {
		return fmt.Errorf("field %s: must be >= %v", "h", 0)
	}
	if 1 < plain.I {
		return fmt.Errorf("field %s: must be <= %v", "i", 1)
	}
	if 0 > plain.I {
		return fmt.Errorf("field %s: must be >= %v", "i", 0)
	}
	if 1 < plain.S {
		return fmt.Errorf("field %s: must be <= %v", "s", 1)
	}
	if 0 > plain.S {
		return fmt.Errorf("field %s: must be >= %v", "s", 0)
	}
	*j = HSIValue(plain)
	return nil
}

type HSLValue struct {
	// H corresponds to the JSON schema field "h".
	H float64 `json:"h" yaml:"h" mapstructure:"h"`

	// L corresponds to the JSON schema field "l".
	L float64 `json:"l" yaml:"l" mapstructure:"l"`

	// Model corresponds to the JSON schema field "model".
	Model *string `json:"model,omitempty" yaml:"model,omitempty" mapstructure:"model,omitempty"`

	// S corresponds to the JSON schema field "s".
	S float64 `json:"s" yaml:"s" mapstructure:"s"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HSLValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["h"]; raw != nil && !ok {
		return fmt.Errorf("field h in HSLValue: required")
	}
	if _, ok := raw["l"]; raw != nil && !ok {
		return fmt.Errorf("field l in HSLValue: required")
	}
	if _, ok := raw["s"]; raw != nil && !ok {
		return fmt.Errorf("field s in HSLValue: required")
	}
	type Plain HSLValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 360 < plain.H {
		return fmt.Errorf("field %s: must be <= %v", "h", 360)
	}
	if 0 > plain.H {
		return fmt.Errorf("field %s: must be >= %v", "h", 0)
	}
	if 1 < plain.L {
		return fmt.Errorf("field %s: must be <= %v", "l", 1)
	}
	if 0 > plain.L {
		return fmt.Errorf("field %s: must be >= %v", "l", 0)
	}
	if 1 < plain.S {
		return fmt.Errorf("field %s: must be <= %v", "s", 1)
	}
	if 0 > plain.S {
		return fmt.Errorf("field %s: must be >= %v", "s", 0)
	}
	*j = HSLValue(plain)
	return nil
}

type HSVValue struct {
	// H corresponds to the JSON schema field "h".
	H float64 `json:"h" yaml:"h" mapstructure:"h"`

	// Model corresponds to the JSON schema field "model".
	Model *string `json:"model,omitempty" yaml:"model,omitempty" mapstructure:"model,omitempty"`

	// S corresponds to the JSON schema field "s".
	S float64 `json:"s" yaml:"s" mapstructure:"s"`

	// V corresponds to the JSON schema field "v".
	V float64 `json:"v" yaml:"v" mapstructure:"v"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HSVValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["h"]; raw != nil && !ok {
		return fmt.Errorf("field h in HSVValue: required")
	}
	if _, ok := raw["s"]; raw != nil && !ok {
		return fmt.Errorf("field s in HSVValue: required")
	}
	if _, ok := raw["v"]; raw != nil && !ok {
		return fmt.Errorf("field v in HSVValue: required")
	}
	type Plain HSVValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 360 < plain.H {
		return fmt.Errorf("field %s: must be <= %v", "h", 360)
	}
	if 0 > plain.H {
		return fmt.Errorf("field %s: must be >= %v", "h", 0)
	}
	if 1 < plain.S {
		return fmt.Errorf("field %s: must be <= %v", "s", 1)
	}
	if 0 > plain.S {
		return fmt.Errorf("field %s: must be >= %v", "s", 0)
	}
	if 1 < plain.V {
		return fmt.Errorf("field %s: must be <= %v", "v", 1)
	}
	if 0 > plain.V {
		return fmt.Errorf("field %s: must be >= %v", "v", 0)
	}
	*j = HSVValue(plain)
	return nil
}

type LABValue struct {
	// A corresponds to the JSON schema field "a".
	A float64 `json:"a" yaml:"a" mapstructure:"a"`

	// B corresponds to the JSON schema field "b".
	B float64 `json:"b" yaml:"b" mapstructure:"b"`

	// L corresponds to the JSON schema field "l".
	L float64 `json:"l" yaml:"l" mapstructure:"l"`

	// Model corresponds to the JSON schema field "model".
	Model *string `json:"model,omitempty" yaml:"model,omitempty" mapstructure:"model,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LABValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["a"]; raw != nil && !ok {
		return fmt.Errorf("field a in LABValue: required")
	}
	if _, ok := raw["b"]; raw != nil && !ok {
		return fmt.Errorf("field b in LABValue: required")
	}
	if _, ok := raw["l"]; raw != nil && !ok {
		return fmt.Errorf("field l in LABValue: required")
	}
	type Plain LABValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 98.254 < plain.A {
		return fmt.Errorf("field %s: must be <= %v", "a", 98.254)
	}
	if -86.185 > plain.A {
		return fmt.Errorf("field %s: must be >= %v", "a", -86.185)
	}
	if 94.482 < plain.B {
		return fmt.Errorf("field %s: must be <= %v", "b", 94.482)
	}
	if -107.863 > plain.B {
		return fmt.Errorf("field %s: must be >= %v", "b", -107.863)
	}
	if 100 < plain.L {
		return fmt.Errorf("field %s: must be <= %v", "l", 100)
	}
	if 0 > plain.L {
		return fmt.Errorf("field %s: must be >= %v", "l", 0)
	}
	*j = LABValue(plain)
	return nil
}

type LCHValue struct {
	// C corresponds to the JSON schema field "c".
	C float64 `json:"c" yaml:"c" mapstructure:"c"`

	// H corresponds to the JSON schema field "h".
	H float64 `json:"h" yaml:"h" mapstructure:"h"`

	// L corresponds to the JSON schema field "l".
	L float64 `json:"l" yaml:"l" mapstructure:"l"`

	// Model corresponds to the JSON schema field "model".
	Model *string `json:"model,omitempty" yaml:"model,omitempty" mapstructure:"model,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LCHValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["c"]; raw != nil && !ok {
		return fmt.Errorf("field c in LCHValue: required")
	}
	if _, ok := raw["h"]; raw != nil && !ok {
		return fmt.Errorf("field h in LCHValue: required")
	}
	if _, ok := raw["l"]; raw != nil && !ok {
		return fmt.Errorf("field l in LCHValue: required")
	}
	type Plain LCHValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 100 < plain.C {
		return fmt.Errorf("field %s: must be <= %v", "c", 100)
	}
	if 0 > plain.C {
		return fmt.Errorf("field %s: must be >= %v", "c", 0)
	}
	if 360 < plain.H {
		return fmt.Errorf("field %s: must be <= %v", "h", 360)
	}
	if 0 > plain.H {
		return fmt.Errorf("field %s: must be >= %v", "h", 0)
	}
	if 100 < plain.L {
		return fmt.Errorf("field %s: must be <= %v", "l", 100)
	}
	if 0 > plain.L {
		return fmt.Errorf("field %s: must be >= %v", "l", 0)
	}
	*j = LCHValue(plain)
	return nil
}

type MatrixPalette struct {
	// ColorScheme corresponds to the JSON schema field "colorScheme".
	ColorScheme *ColorSchemeType `json:"colorScheme,omitempty" yaml:"colorScheme,omitempty" mapstructure:"colorScheme,omitempty"`

	// Colors corresponds to the JSON schema field "colors".
	Colors [][]MatrixPaletteColorsElemElem `json:"colors" yaml:"colors" mapstructure:"colors"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Origin corresponds to the JSON schema field "origin".
	Origin Origin `json:"origin" yaml:"origin" mapstructure:"origin"`

	// Semantic corresponds to the JSON schema field "semantic".
	Semantic *string `json:"semantic" yaml:"semantic" mapstructure:"semantic"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// Usage corresponds to the JSON schema field "usage".
	Usage []string `json:"usage,omitempty" yaml:"usage,omitempty" mapstructure:"usage,omitempty"`
}

type MatrixPaletteColorsElemElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MatrixPalette) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["colors"]; raw != nil && !ok {
		return fmt.Errorf("field colors in MatrixPalette: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in MatrixPalette: required")
	}
	if _, ok := raw["origin"]; raw != nil && !ok {
		return fmt.Errorf("field origin in MatrixPalette: required")
	}
	if _, ok := raw["semantic"]; raw != nil && !ok {
		return fmt.Errorf("field semantic in MatrixPalette: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in MatrixPalette: required")
	}
	type Plain MatrixPalette
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MatrixPalette(plain)
	return nil
}

type Origin struct {
	// X corresponds to the JSON schema field "x".
	X []OriginXElem `json:"x" yaml:"x" mapstructure:"x"`

	// Y corresponds to the JSON schema field "y".
	Y []OriginYElem `json:"y" yaml:"y" mapstructure:"y"`
}

type OriginXElem interface{}

type OriginYElem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Origin) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["x"]; raw != nil && !ok {
		return fmt.Errorf("field x in Origin: required")
	}
	if _, ok := raw["y"]; raw != nil && !ok {
		return fmt.Errorf("field y in Origin: required")
	}
	type Plain Origin
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Origin(plain)
	return nil
}

type Palette interface{}

type RGBAValue struct {
	// A corresponds to the JSON schema field "a".
	A float64 `json:"a" yaml:"a" mapstructure:"a"`

	// B corresponds to the JSON schema field "b".
	B float64 `json:"b" yaml:"b" mapstructure:"b"`

	// G corresponds to the JSON schema field "g".
	G float64 `json:"g" yaml:"g" mapstructure:"g"`

	// Model corresponds to the JSON schema field "model".
	Model *string `json:"model,omitempty" yaml:"model,omitempty" mapstructure:"model,omitempty"`

	// R corresponds to the JSON schema field "r".
	R float64 `json:"r" yaml:"r" mapstructure:"r"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RGBAValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["a"]; raw != nil && !ok {
		return fmt.Errorf("field a in RGBAValue: required")
	}
	if _, ok := raw["b"]; raw != nil && !ok {
		return fmt.Errorf("field b in RGBAValue: required")
	}
	if _, ok := raw["g"]; raw != nil && !ok {
		return fmt.Errorf("field g in RGBAValue: required")
	}
	if _, ok := raw["r"]; raw != nil && !ok {
		return fmt.Errorf("field r in RGBAValue: required")
	}
	type Plain RGBAValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 1 < plain.A {
		return fmt.Errorf("field %s: must be <= %v", "a", 1)
	}
	if 0 > plain.A {
		return fmt.Errorf("field %s: must be >= %v", "a", 0)
	}
	if 255 < plain.B {
		return fmt.Errorf("field %s: must be <= %v", "b", 255)
	}
	if 0 > plain.B {
		return fmt.Errorf("field %s: must be >= %v", "b", 0)
	}
	if 255 < plain.G {
		return fmt.Errorf("field %s: must be <= %v", "g", 255)
	}
	if 0 > plain.G {
		return fmt.Errorf("field %s: must be >= %v", "g", 0)
	}
	if 255 < plain.R {
		return fmt.Errorf("field %s: must be <= %v", "r", 255)
	}
	if 0 > plain.R {
		return fmt.Errorf("field %s: must be >= %v", "r", 0)
	}
	*j = RGBAValue(plain)
	return nil
}

type RGBValue struct {
	// B corresponds to the JSON schema field "b".
	B float64 `json:"b" yaml:"b" mapstructure:"b"`

	// G corresponds to the JSON schema field "g".
	G float64 `json:"g" yaml:"g" mapstructure:"g"`

	// Model corresponds to the JSON schema field "model".
	Model *string `json:"model,omitempty" yaml:"model,omitempty" mapstructure:"model,omitempty"`

	// R corresponds to the JSON schema field "r".
	R float64 `json:"r" yaml:"r" mapstructure:"r"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RGBValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["b"]; raw != nil && !ok {
		return fmt.Errorf("field b in RGBValue: required")
	}
	if _, ok := raw["g"]; raw != nil && !ok {
		return fmt.Errorf("field g in RGBValue: required")
	}
	if _, ok := raw["r"]; raw != nil && !ok {
		return fmt.Errorf("field r in RGBValue: required")
	}
	type Plain RGBValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if 255 < plain.B {
		return fmt.Errorf("field %s: must be <= %v", "b", 255)
	}
	if 0 > plain.B {
		return fmt.Errorf("field %s: must be >= %v", "b", 0)
	}
	if 255 < plain.G {
		return fmt.Errorf("field %s: must be <= %v", "g", 255)
	}
	if 0 > plain.G {
		return fmt.Errorf("field %s: must be >= %v", "g", 0)
	}
	if 255 < plain.R {
		return fmt.Errorf("field %s: must be <= %v", "r", 255)
	}
	if 0 > plain.R {
		return fmt.Errorf("field %s: must be >= %v", "r", 0)
	}
	*j = RGBValue(plain)
	return nil
}

type Undertone string

const UndertoneCool Undertone = "cool"
const UndertoneNeutral Undertone = "neutral"
const UndertoneWarm Undertone = "warm"

var enumValues_Undertone = []interface{}{
	"warm",
	"neutral",
	"cool",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Undertone) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Undertone {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Undertone, v)
	}
	*j = Undertone(v)
	return nil
}
