// Code generated by json-schema-postprocess. DO NOT EDIT.

package testdata

import (
	"encoding/json"
	"fmt"
)

// This file contains unmarshaling and marshaling functions for parent types

// parseUnknownPalette parses an unknown Palette type based on its JSON representation
func parseUnknownPalette(b interface{}) (Palette, error) {
	str, err := json.Marshal(b)
	if err != nil {
		return nil, err
	}

	// Use the type field to determine the type
	type Plain struct {
		Type PaletteType `json:"type" yaml:"type" mapstructure:"type"`
	}
	var plain Plain
	if err := json.Unmarshal(str, &plain); err != nil {
		return nil, err
	}

	switch plain.Type {
	case PaletteTypeContinuous_scale:
		var continuousScalePalette ContinuousScalePalette
		err = json.Unmarshal(str, &continuousScalePalette)
		return &continuousScalePalette, err
	case PaletteTypeMatrix:
		var matrixPalette MatrixPalette
		err = json.Unmarshal(str, &matrixPalette)
		return &matrixPalette, err
	case PaletteTypeCategorical:
		var categoricalPalette CategoricalPalette
		err = json.Unmarshal(str, &categoricalPalette)
		return &categoricalPalette, err
	case PaletteTypeDiscrete_scale:
		var discreteScalePalette DiscreteScalePalette
		err = json.Unmarshal(str, &discreteScalePalette)
		return &discreteScalePalette, err
	default:
		return nil, fmt.Errorf("invalid type: %s", plain.Type)
	}
}

// MarshalJSON implements json.Marshaler for CategoricalPalette
func (j CategoricalPalette) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain CategoricalPalette
	myMarshal := struct {
		Type PaletteType `json:"type" yaml:"type" mapstructure:"type"`
		Plain
	}{
		Type:  j.Type(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// MarshalJSON implements json.Marshaler for DiscreteScalePalette
func (j DiscreteScalePalette) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain DiscreteScalePalette
	myMarshal := struct {
		Type PaletteType `json:"type" yaml:"type" mapstructure:"type"`
		Plain
	}{
		Type:  j.Type(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// MarshalJSON implements json.Marshaler for ContinuousScalePalette
func (j ContinuousScalePalette) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain ContinuousScalePalette
	myMarshal := struct {
		Type PaletteType `json:"type" yaml:"type" mapstructure:"type"`
		Plain
	}{
		Type:  j.Type(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// MarshalJSON implements json.Marshaler for MatrixPalette
func (j MatrixPalette) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain MatrixPalette
	myMarshal := struct {
		Type PaletteType `json:"type" yaml:"type" mapstructure:"type"`
		Plain
	}{
		Type:  j.Type(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// parseUnknownColor parses an unknown Color type based on its JSON representation
func parseUnknownColor(b interface{}) (Color, error) {
	str, err := json.Marshal(b)
	if err != nil {
		return nil, err
	}

	// Use the model field to determine the type
	type Plain struct {
		Model ColorType `json:"model" yaml:"model" mapstructure:"model"`
	}
	var plain Plain
	if err := json.Unmarshal(str, &plain); err != nil {
		return nil, err
	}

	switch plain.Model {
	case ColorTypeHsl:
		var hSLValue HSLValue
		err = json.Unmarshal(str, &hSLValue)
		return &hSLValue, err
	case ColorTypeHsv:
		var hSVValue HSVValue
		err = json.Unmarshal(str, &hSVValue)
		return &hSVValue, err
	case ColorTypeRgba:
		var rGBAValue RGBAValue
		err = json.Unmarshal(str, &rGBAValue)
		return &rGBAValue, err
	case ColorTypeCmyk:
		var cMYKValue CMYKValue
		err = json.Unmarshal(str, &cMYKValue)
		return &cMYKValue, err
	case ColorTypeLch:
		var lCHValue LCHValue
		err = json.Unmarshal(str, &lCHValue)
		return &lCHValue, err
	case ColorTypeHsi:
		var hSIValue HSIValue
		err = json.Unmarshal(str, &hSIValue)
		return &hSIValue, err
	case ColorTypeRgb:
		var rGBValue RGBValue
		err = json.Unmarshal(str, &rGBValue)
		return &rGBValue, err
	case ColorTypeLab:
		var lABValue LABValue
		err = json.Unmarshal(str, &lABValue)
		return &lABValue, err
	default:
		return nil, fmt.Errorf("invalid model: %s", plain.Model)
	}
}

// MarshalJSON implements json.Marshaler for HSIValue
func (j HSIValue) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain HSIValue
	myMarshal := struct {
		Model ColorType `json:"model" yaml:"model" mapstructure:"model"`
		Plain
	}{
		Model: j.Model(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// MarshalJSON implements json.Marshaler for RGBValue
func (j RGBValue) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain RGBValue
	myMarshal := struct {
		Model ColorType `json:"model" yaml:"model" mapstructure:"model"`
		Plain
	}{
		Model: j.Model(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// MarshalJSON implements json.Marshaler for LABValue
func (j LABValue) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain LABValue
	myMarshal := struct {
		Model ColorType `json:"model" yaml:"model" mapstructure:"model"`
		Plain
	}{
		Model: j.Model(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// MarshalJSON implements json.Marshaler for HSLValue
func (j HSLValue) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain HSLValue
	myMarshal := struct {
		Model ColorType `json:"model" yaml:"model" mapstructure:"model"`
		Plain
	}{
		Model: j.Model(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// MarshalJSON implements json.Marshaler for HSVValue
func (j HSVValue) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain HSVValue
	myMarshal := struct {
		Model ColorType `json:"model" yaml:"model" mapstructure:"model"`
		Plain
	}{
		Model: j.Model(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// MarshalJSON implements json.Marshaler for RGBAValue
func (j RGBAValue) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain RGBAValue
	myMarshal := struct {
		Model ColorType `json:"model" yaml:"model" mapstructure:"model"`
		Plain
	}{
		Model: j.Model(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// MarshalJSON implements json.Marshaler for CMYKValue
func (j CMYKValue) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain CMYKValue
	myMarshal := struct {
		Model ColorType `json:"model" yaml:"model" mapstructure:"model"`
		Plain
	}{
		Model: j.Model(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// MarshalJSON implements json.Marshaler for LCHValue
func (j LCHValue) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain LCHValue
	myMarshal := struct {
		Model ColorType `json:"model" yaml:"model" mapstructure:"model"`
		Plain
	}{
		Model: j.Model(),
		Plain: Plain(j),
	}
	return json.Marshal(myMarshal)
}

// UnmarshalJSON implements json.Unmarshaler for ColorConfig
func (j *ColorConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in ColorConfig: required")
	}

	type Plain ColorConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}

	// Parse Color type
	if raw["value"] != nil {
		parsed, err := parseUnknownColor(raw["value"])
		if err != nil {
			return err
		}
		plain.Value = parsed
	}

	*j = ColorConfig(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler for MatrixPalette
func (j *MatrixPalette) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["colors"]; raw != nil && !ok {
		return fmt.Errorf("field colors in MatrixPalette: required")
	}

	type Plain MatrixPalette
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}

	// Parse array of Color types
	if raw["colors"] != nil {
		arr, ok := raw["colors"].([]interface{})
		if ok {
			colors := make(ColorSlice, 0, len(arr))
			for _, item := range arr {
				parsed, err := parseUnknownColor(item)
				if err != nil {
					return err
				}
				colors = append(colors, parsed)
			}
			plain.Colors = colors
		}
	}

	*j = MatrixPalette(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler for AssetPack
func (j *AssetPack) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["palettes"]; raw != nil && !ok {
		return fmt.Errorf("field palettes in AssetPack: required")
	}

	type Plain AssetPack
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}

	// Parse array of Palette types
	if raw["palettes"] != nil {
		arr, ok := raw["palettes"].([]interface{})
		if ok {
			palettes := make(PaletteSlice, 0, len(arr))
			for _, item := range arr {
				parsed, err := parseUnknownPalette(item)
				if err != nil {
					return err
				}
				palettes = append(palettes, parsed)
			}
			plain.Palettes = palettes
		}
	}

	*j = AssetPack(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler for ContinuousColor
func (j *ContinuousColor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in ContinuousColor: required")
	}

	type Plain ContinuousColor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}

	// Parse Color type
	if raw["value"] != nil {
		parsed, err := parseUnknownColor(raw["value"])
		if err != nil {
			return err
		}
		plain.Value = parsed
	}

	*j = ContinuousColor(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler for DiscreteScalePalette
func (j *DiscreteScalePalette) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["colors"]; raw != nil && !ok {
		return fmt.Errorf("field colors in DiscreteScalePalette: required")
	}

	type Plain DiscreteScalePalette
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}

	// Parse array of Color types
	if raw["colors"] != nil {
		arr, ok := raw["colors"].([]interface{})
		if ok {
			colors := make(ColorSlice, 0, len(arr))
			for _, item := range arr {
				parsed, err := parseUnknownColor(item)
				if err != nil {
					return err
				}
				colors = append(colors, parsed)
			}
			plain.Colors = colors
		}
	}

	*j = DiscreteScalePalette(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler for Origin
func (j *Origin) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["x"]; raw != nil && !ok {
		return fmt.Errorf("field x in Origin: required")
	}

	type Plain Origin
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}

	// Parse array of Color types
	if raw["x"] != nil {
		arr, ok := raw["x"].([]interface{})
		if ok {
			x := make(ColorSlice, 0, len(arr))
			for _, item := range arr {
				parsed, err := parseUnknownColor(item)
				if err != nil {
					return err
				}
				x = append(x, parsed)
			}
			plain.X = x
		}
	}

	*j = Origin(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler for Origin
func (j *Origin) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["y"]; raw != nil && !ok {
		return fmt.Errorf("field y in Origin: required")
	}

	type Plain Origin
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}

	// Parse array of Color types
	if raw["y"] != nil {
		arr, ok := raw["y"].([]interface{})
		if ok {
			y := make(ColorSlice, 0, len(arr))
			for _, item := range arr {
				parsed, err := parseUnknownColor(item)
				if err != nil {
					return err
				}
				y = append(y, parsed)
			}
			plain.Y = y
		}
	}

	*j = Origin(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler for CategoricalPalette
func (j *CategoricalPalette) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["colors"]; raw != nil && !ok {
		return fmt.Errorf("field colors in CategoricalPalette: required")
	}

	type Plain CategoricalPalette
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}

	// Parse array of Color types
	if raw["colors"] != nil {
		arr, ok := raw["colors"].([]interface{})
		if ok {
			colors := make(ColorSlice, 0, len(arr))
			for _, item := range arr {
				parsed, err := parseUnknownColor(item)
				if err != nil {
					return err
				}
				colors = append(colors, parsed)
			}
			plain.Colors = colors
		}
	}

	*j = CategoricalPalette(plain)
	return nil
}
