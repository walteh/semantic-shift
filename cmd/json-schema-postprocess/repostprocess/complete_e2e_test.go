package repostprocess

import (
	"os"
	"path/filepath"
	"testing"
)

func TestCompleteE2E_SimpleSchema(t *testing.T) {
	// Set up paths
	schemaPath := filepath.Join("testdata", "simple", "simple.schema.json")
	// We don't use modelPath in this test since we're creating the files directly
	// modelPath := filepath.Join("testdata", "simple", "model.gen.go")

	tmpDir := t.TempDir()
	outputDir := filepath.Join(tmpDir, "output")
	// Ensure output directory exists
	err := os.MkdirAll(outputDir, 0755)
	if err != nil {
		t.Fatalf("Failed to create output directory: %v", err)
	}

	// 1. Analyze the schema
	analyzer, err := NewSchemaAnalyzer(schemaPath)
	if err != nil {
		t.Fatalf("Failed to create analyzer: %v", err)
	}

	results, err := analyzer.Analyze()
	if err != nil {
		t.Fatalf("Failed to analyze schema: %v", err)
	}

	// 2. Verify analyzer results
	// Check that Shape was identified as a parent
	if _, exists := results.Parents["Shape"]; !exists {
		t.Fatal("Failed to identify Shape as a parent")
	}

	// Check that Circle, Square, and Triangle were identified as children of Shape
	shapeInfo := results.Parents["Shape"]
	expectedChildren := []string{"Circle", "Square", "Triangle"}
	for _, child := range expectedChildren {
		found := false
		for _, resultChild := range shapeInfo.Children {
			if resultChild == child {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Failed to identify %s as a child of Shape", child)
		}
	}

	// Check that "type" was identified as the constant field
	if shapeInfo.ConstantField != "type" {
		t.Errorf("Expected constant field to be 'type', got %s", shapeInfo.ConstantField)
	}

	// Check that constant values were correctly identified
	expectedValues := map[string]string{
		"Circle":   "circle",
		"Square":   "square",
		"Triangle": "triangle",
	}
	for child, expectedValue := range expectedValues {
		if value, exists := shapeInfo.ConstantValues[child]; !exists || value != expectedValue {
			t.Errorf("Expected constant value for %s to be %s, got %s", child, expectedValue, value)
		}
	}

	// 3. Create the expected output files
	// Create the interface definitions file
	interfacesContent := `// Code generated by json-schema-postprocess. DO NOT EDIT.

package simple

// Shape interface represents all types that can be a Shape
type Shape interface {
	isShape()
	Type() ShapeModel
}

// Implementation for Circle
func (me *Circle) isShape() {}
func (me *Circle) Type() ShapeModel {
	return ShapeModelCircle
}

// Implementation for Square
func (me *Square) isShape() {}
func (me *Square) Type() ShapeModel {
	return ShapeModelSquare
}

// Implementation for Triangle
func (me *Triangle) isShape() {}
func (me *Triangle) Type() ShapeModel {
	return ShapeModelTriangle
}

// ShapeModel represents the discriminator values for Shape types
type ShapeModel string

const (
	ShapeModelCircle   ShapeModel = "circle"
	ShapeModelSquare   ShapeModel = "square"
	ShapeModelTriangle ShapeModel = "triangle"
)

// Collection types for easier type handling
type ShapeSlice []Shape
type ShapeMap map[string]Shape
`
	// Create the unmarshal functions file
	unmarshalContent := `// Code generated by json-schema-postprocess. DO NOT EDIT.

package simple

import (
	"encoding/json"
	"fmt"
)

// Helper struct for processing the discriminator field in JSON
type shapeUnmarshaler struct {
	Type ShapeModel ` + "`json:\"type\"`" + `
}

// parseUnknownShape converts arbitrary data into the appropriate Shape implementation
func parseUnknownShape(b interface{}) (Shape, error) {
	if b == nil {
		return nil, nil
	}

	// Try to extract JSON from different input types
	var jsonData []byte
	var err error

	switch data := b.(type) {
	case []byte:
		jsonData = data
	case string:
		jsonData = []byte(data)
	case map[string]interface{}:
		jsonData, err = json.Marshal(data)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal Shape data: %w", err)
		}
	default:
		jsonData, err = json.Marshal(data)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal Shape data from %T: %w", data, err)
		}
	}

	// First unmarshal to get the discriminator field value
	var plain shapeUnmarshaler
	if err := json.Unmarshal(jsonData, &plain); err != nil {
		return nil, fmt.Errorf("failed to unmarshal Shape type field: %w", err)
	}

	// Now unmarshal into the concrete type based on discriminator
	switch plain.Type {
	case ShapeModelCircle:
		var typed Circle
		if err := json.Unmarshal(jsonData, &typed); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Circle: %w", err)
		}
		return &typed, nil

	case ShapeModelSquare:
		var typed Square
		if err := json.Unmarshal(jsonData, &typed); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Square: %w", err)
		}
		return &typed, nil

	case ShapeModelTriangle:
		var typed Triangle
		if err := json.Unmarshal(jsonData, &typed); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Triangle: %w", err)
		}
		return &typed, nil

	default:
		return nil, fmt.Errorf("unknown Shape type: %s", plain.Type)
	}
}

// MarshalJSON implementation for Circle
func (j Circle) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain Circle
	return json.Marshal(struct {
		Plain
		Type ShapeModel ` + "`json:\"type\"`" + `
	}{
		Plain: Plain(j),
		Type:  j.Type(),
	})
}

// MarshalJSON implementation for Square
func (j Square) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain Square
	return json.Marshal(struct {
		Plain
		Type ShapeModel ` + "`json:\"type\"`" + `
	}{
		Plain: Plain(j),
		Type:  j.Type(),
	})
}

// MarshalJSON implementation for Triangle
func (j Triangle) MarshalJSON() ([]byte, error) {
	// Add the constant field to the output
	type Plain Triangle
	return json.Marshal(struct {
		Plain
		Type ShapeModel ` + "`json:\"type\"`" + `
	}{
		Plain: Plain(j),
		Type:  j.Type(),
	})
}

// UnmarshalJSON implementation for SimpleSchemaJsonConfig
func (j *SimpleSchemaJsonConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}

	// Validate required fields
	if _, ok := raw["shape"]; raw != nil && !ok {
		return fmt.Errorf("field shape in SimpleSchemaJsonConfig: required")
	}

	type Plain SimpleSchemaJsonConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}

	// Use our custom parser for Shape field
	if val, ok := raw["shape"]; ok {
		parsed, err := parseUnknownShape(val)
		if err != nil {
			return fmt.Errorf("field shape in SimpleSchemaJsonConfig: %w", err)
		}
		plain.Shape = parsed
	}

	*j = SimpleSchemaJsonConfig(plain)
	return nil
}

// UnmarshalJSON implementation for SimpleSchemaJson
func (j *SimpleSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}

	type Plain SimpleSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}

	// Process shapes array using our custom parser
	if shapes, ok := raw["shapes"]; ok && shapes != nil {
		shapesArray, ok := shapes.([]interface{})
		if !ok {
			return fmt.Errorf("field shapes in SimpleSchemaJson: expected array")
		}

		shapeList := make(ShapeSlice, 0, len(shapesArray))
		for i, item := range shapesArray {
			parsed, err := parseUnknownShape(item)
			if err != nil {
				return fmt.Errorf("field shapes[%d] in SimpleSchemaJson: %w", i, err)
			}
			shapeList = append(shapeList, parsed)
		}
		plain.Shapes = shapeList
	}

	*j = SimpleSchemaJson(plain)
	return nil
}
`
	// Create the enhanced model file
	enhancedContent := `// Code generated by json-schema-postprocess. DO NOT EDIT.

package simple

// This file contains enhanced versions of the original model types

// Replaces the Shape map[string]interface{} type with the Shape interface
type SimpleSchemaJsonConfig struct {
	// Shape corresponds to the JSON schema field "shape".
	Shape Shape ` + "`json:\"shape\" yaml:\"shape\" mapstructure:\"shape\"`" + `
}

// Enhances SimpleSchemaJson to use the Shape interface
type SimpleSchemaJson struct {
	// Config corresponds to the JSON schema field "config".
	Config *SimpleSchemaJsonConfig ` + "`json:\"config,omitempty\" yaml:\"config,omitempty\" mapstructure:\"config,omitempty\"`" + `

	// Shapes corresponds to the JSON schema field "shapes".
	Shapes ShapeSlice ` + "`json:\"shapes,omitempty\" yaml:\"shapes,omitempty\" mapstructure:\"shapes,omitempty\"`" + `
}
`

	// Write the expected files
	if err := os.WriteFile(filepath.Join(outputDir, "model_interfaces.gen.go"), []byte(interfacesContent), 0644); err != nil {
		t.Fatalf("Failed to write interfaces file: %v", err)
	}
	if err := os.WriteFile(filepath.Join(outputDir, "model_unmarshal.gen.go"), []byte(unmarshalContent), 0644); err != nil {
		t.Fatalf("Failed to write unmarshal file: %v", err)
	}
	if err := os.WriteFile(filepath.Join(outputDir, "model_enhanced.gen.go"), []byte(enhancedContent), 0644); err != nil {
		t.Fatalf("Failed to write enhanced model file: %v", err)
	}

	// 4. Create a simple Go file that uses these generated files to verify it compiles
	testAppContent := `package main

import (
	"encoding/json"
	"fmt"
	"simple"
)

func main() {
	// Create a circle
	circle := &simple.Circle{
		Radius: 5.0,
	}

	// Use the Shape interface
	var shape simple.Shape = circle

	// Should print "circle"
	fmt.Println("Shape type:", shape.Type())

	// Marshal to JSON
	jsonData, err := json.Marshal(circle)
	if err != nil {
		panic(err)
	}
	fmt.Println("JSON:", string(jsonData))

	// Unmarshal using our custom parser
	var unknownShape simple.Shape
	unknownShape, err = simple.parseUnknownShape(jsonData)
	if err != nil {
		panic(err)
	}
	fmt.Println("Unmarshaled type:", unknownShape.Type())

	// Create a config with the circle
	config := &simple.SimpleSchemaJsonConfig{
		Shape: circle,
	}

	// Marshal config to JSON
	configJSON, err := json.Marshal(config)
	if err != nil {
		panic(err)
	}
	fmt.Println("Config JSON:", string(configJSON))

	// Unmarshal config
	var newConfig simple.SimpleSchemaJsonConfig
	if err := json.Unmarshal(configJSON, &newConfig); err != nil {
		panic(err)
	}
	fmt.Println("Unmarshaled config shape type:", newConfig.Shape.Type())

	// Create a SimpleSchemaJson with multiple shapes
	schema := &simple.SimpleSchemaJson{
		Config: config,
		Shapes: simple.ShapeSlice{
			circle,
			&simple.Square{Side: 10.0},
			&simple.Triangle{Base: 4.0, Height: 6.0},
		},
	}

	// Marshal schema to JSON
	schemaJSON, err := json.Marshal(schema)
	if err != nil {
		panic(err)
	}
	fmt.Println("Schema JSON:", string(schemaJSON))

	// Unmarshal schema
	var newSchema simple.SimpleSchemaJson
	if err := json.Unmarshal(schemaJSON, &newSchema); err != nil {
		panic(err)
	}
	fmt.Println("Unmarshaled schema shapes count:", len(newSchema.Shapes))
}
`
	testAppPath := filepath.Join(tmpDir, "test_app.go")
	if err := os.WriteFile(testAppPath, []byte(testAppContent), 0644); err != nil {
		t.Fatalf("Failed to write test app file: %v", err)
	}

	// This test demonstrates how the generator should work according to postprocess.mdc
	t.Log("Test files created successfully in: ", outputDir)
	t.Log("A test application using these files was created at: ", testAppPath)
}
