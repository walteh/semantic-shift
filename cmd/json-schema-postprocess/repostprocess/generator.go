package repostprocess

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"gitlab.com/tozd/go/errors"
)

// CodeGenerator is responsible for generating updated Go code
// based on the schema analysis results
type CodeGenerator struct {
	modelPath string
	outputDir string
	results   *SchemaResults
}

// NewCodeGenerator creates a new code generator
func NewCodeGenerator(modelPath, outputDir string, results *SchemaResults) *CodeGenerator {
	return &CodeGenerator{
		modelPath: modelPath,
		outputDir: outputDir,
		results:   results,
	}
}

// Generate performs the code generation
func (cg *CodeGenerator) Generate() error {
	// Step 1: Generate interface and implementation methods
	if err := cg.generateInterfaces(); err != nil {
		return errors.Errorf("generating interfaces: %w", err)
	}

	// Step 2: Generate parseUnknown functions
	if err := cg.generateUnmarshalFunctions(); err != nil {
		return errors.Errorf("generating unmarshal functions: %w", err)
	}

	// Step 3-4: Generate enhanced model with modified types
	if err := cg.generateEnhancedModel(); err != nil {
		return errors.Errorf("generating enhanced model: %w", err)
	}

	return nil
}

// generateInterfaces creates interface definitions and implementation methods for each parent type
func (cg *CodeGenerator) generateInterfaces() error {
	var buf bytes.Buffer

	// Write file header
	buf.WriteString("// Code generated by json-schema-postprocess. DO NOT EDIT.\n\n")
	buf.WriteString("package testdata\n\n")
	buf.WriteString("// This file contains interface definitions and implementation methods for parent types\n\n")

	// For each parent, create an interface and implementation methods
	for parentName, info := range cg.results.Parents {
		// Create the interface
		buf.WriteString(fmt.Sprintf("// %s represents the parent type for %s types\n", parentName, parentName))
		buf.WriteString(fmt.Sprintf("type %s interface {\n", parentName))
		buf.WriteString(fmt.Sprintf("\tis%s()\n", parentName))

		// Add constant field method if present
		if info.ConstantField != "" {
			constFieldName := strings.Title(info.ConstantField)
			buf.WriteString(fmt.Sprintf("\t%s() %sModel\n", constFieldName, parentName))
		}

		buf.WriteString("}\n\n")

		// Add slice and map types
		buf.WriteString(fmt.Sprintf("// %sSlice is a slice of %s interfaces\n", parentName, parentName))
		buf.WriteString(fmt.Sprintf("type %sSlice []%s\n\n", parentName, parentName))
		buf.WriteString(fmt.Sprintf("// %sMap is a map of %s interfaces\n", parentName, parentName))
		buf.WriteString(fmt.Sprintf("type %sMap map[string]%s\n\n", parentName, parentName))

		// Track which implementation methods we've written to avoid duplicates
		written := make(map[string]bool)

		// Add implementation methods for each child
		for _, childName := range info.Children {
			// Skip if we've already written this implementation
			implKey := childName + ".is" + parentName
			if written[implKey] {
				continue
			}
			written[implKey] = true

			// Add the interface implementation method
			buf.WriteString(fmt.Sprintf("// is%s implements the %s interface\n", parentName, parentName))
			buf.WriteString(fmt.Sprintf("func (me *%s) is%s() {}\n\n", childName, parentName))

			// Add constant field implementation if present
			if info.ConstantField != "" {
				constFieldName := strings.Title(info.ConstantField)
				constValue, ok := info.ConstantValues[childName]

				if ok && constValue != "" {
					methodKey := childName + "." + constFieldName
					if written[methodKey] {
						continue
					}
					written[methodKey] = true

					sanitizedValue := sanitizeIdentifier(constValue)
					typeName := fmt.Sprintf("%sModel", parentName)
					constName := fmt.Sprintf("%s%s", typeName, strings.Title(sanitizedValue))

					buf.WriteString(fmt.Sprintf("// %s returns the %s type constant\n", constFieldName, parentName))
					buf.WriteString(fmt.Sprintf("func (me *%s) %s() %s { return %s }\n\n",
						childName, constFieldName, typeName, constName))
				}
			}
		}

		// If we have a constant field, add a type and constants for the values
		if info.ConstantField != "" {
			typeName := fmt.Sprintf("%sModel", parentName)
			buf.WriteString(fmt.Sprintf("// %s represents the %s model type\n", typeName, info.ConstantField))
			buf.WriteString(fmt.Sprintf("type %s string\n\n", typeName))

			buf.WriteString("// Constants for the different model types\n")
			buf.WriteString("const (\n")

			// Track constants to avoid duplicates
			constWritten := make(map[string]bool)

			for _, constValue := range info.ConstantValues {
				if constWritten[constValue] {
					continue
				}
				constWritten[constValue] = true

				sanitizedValue := sanitizeIdentifier(constValue)
				constName := fmt.Sprintf("%s%s", typeName, strings.Title(sanitizedValue))
				buf.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, typeName, constValue))
			}

			buf.WriteString(")\n\n")
		}
	}

	// Format the code
	formattedBytes, err := format.Source(buf.Bytes())
	if err != nil {
		return errors.Errorf("formatting generated code: %w", err)
	}

	// Write to file
	outputPath := filepath.Join(cg.outputDir, "model_interfaces.gen.go")
	if err := os.WriteFile(outputPath, formattedBytes, 0644); err != nil {
		return errors.Errorf("writing interfaces file: %w", err)
	}

	return nil
}

// generateUnmarshalFunctions creates the parseUnknown functions and MarshalJSON methods
func (cg *CodeGenerator) generateUnmarshalFunctions() error {
	var buf bytes.Buffer

	// Write file header
	buf.WriteString("// Code generated by json-schema-postprocess. DO NOT EDIT.\n\n")
	buf.WriteString("package testdata\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString(")\n\n")
	buf.WriteString("// This file contains unmarshaling and marshaling functions for parent types\n\n")

	// Generate parseUnknown functions for each parent
	for parentName, info := range cg.results.Parents {
		if len(info.Children) == 0 {
			continue
		}

		// Create parseUnknown function
		buf.WriteString(fmt.Sprintf("// parseUnknown%s parses an unknown %s type based on its JSON representation\n", parentName, parentName))
		buf.WriteString(fmt.Sprintf("func parseUnknown%s(b interface{}) (%s, error) {\n", parentName, parentName))
		buf.WriteString("\tstr, err := json.Marshal(b)\n")
		buf.WriteString("\tif err != nil {\n")
		buf.WriteString("\t\treturn nil, err\n")
		buf.WriteString("\t}\n\n")

		// If we have a constant field, use it to determine the type
		if info.ConstantField != "" {
			buf.WriteString(fmt.Sprintf("\t// Use the %s field to determine the type\n", info.ConstantField))
			buf.WriteString("\ttype Plain struct {\n")
			buf.WriteString(fmt.Sprintf("\t\t%s %sModel `json:\"%s\" yaml:\"%s\" mapstructure:\"%s\"`\n",
				strings.Title(info.ConstantField), parentName, info.ConstantField, info.ConstantField, info.ConstantField))
			buf.WriteString("\t}\n")
			buf.WriteString("\tvar plain Plain\n")
			buf.WriteString("\tif err := json.Unmarshal(str, &plain); err != nil {\n")
			buf.WriteString("\t\treturn nil, err\n")
			buf.WriteString("\t}\n\n")

			buf.WriteString("\tswitch plain." + strings.Title(info.ConstantField) + " {\n")

			// Add a case for each child
			for childName, constValue := range info.ConstantValues {
				sanitizedValue := sanitizeIdentifier(constValue)
				constName := fmt.Sprintf("%sModel%s", parentName, strings.Title(sanitizedValue))

				buf.WriteString(fmt.Sprintf("\tcase %s:\n", constName))
				buf.WriteString(fmt.Sprintf("\t\tvar %s %s\n", camelCase(childName), childName))
				buf.WriteString(fmt.Sprintf("\t\terr = json.Unmarshal(str, &%s)\n", camelCase(childName)))
				buf.WriteString(fmt.Sprintf("\t\treturn &%s, err\n", camelCase(childName)))
			}

			buf.WriteString("\tdefault:\n")
			buf.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"invalid %s: %%s\", plain.%s)\n",
				info.ConstantField, strings.Title(info.ConstantField)))
			buf.WriteString("\t}\n")
		} else {
			// No constant field, try each option
			buf.WriteString("\t// Try each possible type\n")
			buf.WriteString("\topts := []" + parentName + "{\n")

			// Add each child to the options
			for _, childName := range info.Children {
				buf.WriteString(fmt.Sprintf("\t\t&%s{},\n", childName))
			}

			buf.WriteString("\t}\n\n")

			buf.WriteString("\tfor _, opt := range opts {\n")
			buf.WriteString("\t\terr = json.Unmarshal(str, opt)\n")
			buf.WriteString("\t\tif err == nil {\n")
			buf.WriteString("\t\t\treturn opt, nil\n")
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t}\n\n")

			buf.WriteString(fmt.Sprintf("\treturn nil, fmt.Errorf(\"invalid %s\")\n", parentName))
		}

		buf.WriteString("}\n\n")

		// Generate MarshalJSON methods for children with constant fields
		if info.ConstantField != "" {
			for childName := range info.ConstantValues {
				buf.WriteString(fmt.Sprintf("// MarshalJSON implements json.Marshaler for %s\n", childName))
				buf.WriteString(fmt.Sprintf("func (j %s) MarshalJSON() ([]byte, error) {\n", childName))
				buf.WriteString("\t// Add the constant field to the output\n")
				buf.WriteString(fmt.Sprintf("\ttype Plain %s\n", childName))
				buf.WriteString("\tmyMarshal := struct {\n")
				buf.WriteString(fmt.Sprintf("\t\t%s %sModel `json:\"%s\" yaml:\"%s\" mapstructure:\"%s\"`\n",
					strings.Title(info.ConstantField), parentName, info.ConstantField, info.ConstantField, info.ConstantField))
				buf.WriteString("\t\tPlain\n")
				buf.WriteString("\t}{\n")
				buf.WriteString(fmt.Sprintf("\t\t%s: j.%s(),\n", strings.Title(info.ConstantField), strings.Title(info.ConstantField)))
				buf.WriteString("\t\tPlain: Plain(j),\n")
				buf.WriteString("\t}\n")
				buf.WriteString("\treturn json.Marshal(myMarshal)\n")
				buf.WriteString("}\n\n")
			}
		}
	}

	// Generate modified UnmarshalJSON methods for parent callers
	for _, caller := range cg.results.ParentCallers {
		if !caller.IsRequired {
			continue
		}

		parentName := caller.ParentRef
		structName := caller.Name
		fieldName := caller.Field
		titleField := strings.Title(fieldName)

		// Generate a modified UnmarshalJSON method
		buf.WriteString(fmt.Sprintf("// UnmarshalJSON implements json.Unmarshaler for %s\n", structName))
		buf.WriteString(fmt.Sprintf("func (j *%s) UnmarshalJSON(b []byte) error {\n", structName))
		buf.WriteString("\tvar raw map[string]interface{}\n")
		buf.WriteString("\tif err := json.Unmarshal(b, &raw); err != nil {\n")
		buf.WriteString("\t\treturn err\n")
		buf.WriteString("\t}\n")

		// Check if required field is present
		buf.WriteString(fmt.Sprintf("\tif _, ok := raw[\"%s\"]; raw != nil && !ok {\n", fieldName))
		buf.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"field %s in %s: required\")\n", fieldName, structName))
		buf.WriteString("\t}\n\n")

		buf.WriteString(fmt.Sprintf("\ttype Plain %s\n", structName))
		buf.WriteString("\tvar plain Plain\n")
		buf.WriteString("\tif err := json.Unmarshal(b, &plain); err != nil {\n")
		buf.WriteString("\t\treturn err\n")
		buf.WriteString("\t}\n\n")

		// If caller is a direct reference
		if caller.IsArray {
			// Handle array of parent types
			buf.WriteString(fmt.Sprintf("\t// Parse array of %s types\n", parentName))
			buf.WriteString(fmt.Sprintf("\tif raw[\"%s\"] != nil {\n", fieldName))
			buf.WriteString(fmt.Sprintf("\t\tarr, ok := raw[\"%s\"].([]interface{})\n", fieldName))
			buf.WriteString("\t\tif ok {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t%s := make(%sSlice, 0, len(arr))\n", camelCase(fieldName), parentName))
			buf.WriteString("\t\t\tfor _, item := range arr {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\tparsed, err := parseUnknown%s(item)\n", parentName))
			buf.WriteString("\t\t\t\tif err != nil {\n")
			buf.WriteString("\t\t\t\t\treturn err\n")
			buf.WriteString("\t\t\t\t}\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\t%s = append(%s, parsed)\n", camelCase(fieldName), camelCase(fieldName)))
			buf.WriteString("\t\t\t}\n")
			buf.WriteString(fmt.Sprintf("\t\t\tplain.%s = %s\n", titleField, camelCase(fieldName)))
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t}\n\n")
		} else if caller.IsMap {
			// Handle map of parent types
			buf.WriteString(fmt.Sprintf("\t// Parse map of %s types\n", parentName))
			buf.WriteString(fmt.Sprintf("\tif raw[\"%s\"] != nil {\n", fieldName))
			buf.WriteString(fmt.Sprintf("\t\tmap_, ok := raw[\"%s\"].(map[string]interface{})\n", fieldName))
			buf.WriteString("\t\tif ok {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t%s := make(%sMap)\n", camelCase(fieldName), parentName))
			buf.WriteString("\t\t\tfor key, item := range map_ {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\tparsed, err := parseUnknown%s(item)\n", parentName))
			buf.WriteString("\t\t\t\tif err != nil {\n")
			buf.WriteString("\t\t\t\t\treturn err\n")
			buf.WriteString("\t\t\t\t}\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\t%s[key] = parsed\n", camelCase(fieldName)))
			buf.WriteString("\t\t\t}\n")
			buf.WriteString(fmt.Sprintf("\t\t\tplain.%s = %s\n", titleField, camelCase(fieldName)))
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t}\n\n")
		} else {
			// Direct reference
			buf.WriteString(fmt.Sprintf("\t// Parse %s type\n", parentName))
			buf.WriteString(fmt.Sprintf("\tif raw[\"%s\"] != nil {\n", fieldName))
			buf.WriteString(fmt.Sprintf("\t\tparsed, err := parseUnknown%s(raw[\"%s\"])\n", parentName, fieldName))
			buf.WriteString("\t\tif err != nil {\n")
			buf.WriteString("\t\t\treturn err\n")
			buf.WriteString("\t\t}\n")
			buf.WriteString(fmt.Sprintf("\t\tplain.%s = parsed\n", titleField))
			buf.WriteString("\t}\n\n")
		}

		buf.WriteString(fmt.Sprintf("\t*j = %s(plain)\n", structName))
		buf.WriteString("\treturn nil\n")
		buf.WriteString("}\n\n")
	}

	// Format the code
	formattedBytes, err := format.Source(buf.Bytes())
	if err != nil {
		return errors.Errorf("formatting generated code: %w", err)
	}

	// Write to file
	outputPath := filepath.Join(cg.outputDir, "model_unmarshal.gen.go")
	if err := os.WriteFile(outputPath, formattedBytes, 0644); err != nil {
		return errors.Errorf("writing unmarshal file: %w", err)
	}

	return nil
}

// generateEnhancedModel creates a modified version of the model with updated type definitions
func (cg *CodeGenerator) generateEnhancedModel() error {
	// Parse the original model file
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, cg.modelPath, nil, parser.ParseComments)
	if err != nil {
		return errors.Errorf("parsing model file: %w", err)
	}

	// Create a new file with the same package name
	newFile := &ast.File{
		Name:    node.Name,
		Doc:     &ast.CommentGroup{List: []*ast.Comment{{Text: "// Code generated by json-schema-postprocess. DO NOT EDIT."}}},
		Imports: node.Imports,
		Decls:   []ast.Decl{},
	}

	// Track interface types to remove
	removeInterfaceNames := make(map[string]bool)

	// Identify interface types ending with "Elem" or "Value" that should be removed
	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// Check if this is an interface type
			if _, ok := typeSpec.Type.(*ast.InterfaceType); ok {
				name := typeSpec.Name.Name

				// Check if it's a parent caller interface
				for _, parentInfo := range cg.results.Parents {
					for _, child := range parentInfo.Children {
						interfaceName := child + "Value"
						if name == interfaceName {
							removeInterfaceNames[name] = true
						}
					}
				}

				// Check for array element interfaces
				for _, caller := range cg.results.ArrayParentCallers {
					elemName := caller.Name + caller.Field + "Elem"
					if name == elemName {
						removeInterfaceNames[name] = true
					}
				}
			}
		}
	}

	// Process declarations, modifying struct types as needed
	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			newFile.Decls = append(newFile.Decls, decl)
			continue
		}

		if genDecl.Tok != token.TYPE {
			newFile.Decls = append(newFile.Decls, genDecl)
			continue
		}

		// Process type declarations
		newSpecs := []ast.Spec{}
		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				newSpecs = append(newSpecs, spec)
				continue
			}

			// Skip interface types that we want to remove
			if _, ok := typeSpec.Type.(*ast.InterfaceType); ok && removeInterfaceNames[typeSpec.Name.Name] {
				continue
			}

			// Modify struct types if needed
			if structType, ok := typeSpec.Type.(*ast.StructType); ok {
				newFields := []*ast.Field{}
				for _, field := range structType.Fields.List {
					if len(field.Names) == 0 {
						newFields = append(newFields, field)
						continue
					}

					fieldName := field.Names[0].Name
					jsonTag := ""
					if field.Tag != nil {
						tag := field.Tag.Value
						if strings.Contains(tag, "json:") {
							start := strings.Index(tag, "json:\"") + 6
							end := start
							for end < len(tag) && tag[end] != '"' && tag[end] != ',' {
								end++
							}
							if end > start {
								jsonTag = tag[start:end]
							}
						}
					}

					// Check for field modifications
					for _, caller := range cg.results.ArrayParentCallers {
						if caller.Name == typeSpec.Name.Name && (caller.Field == fieldName || caller.Field == jsonTag) {
							// Modify the field type to use the parent slice type
							if _, ok := field.Type.(*ast.ArrayType); ok {
								field.Type = &ast.Ident{Name: caller.ParentRef + "Slice"}
							}
						}
					}

					// Check for direct parent callers
					for _, caller := range cg.results.DirectParentCallers {
						if caller.Name == typeSpec.Name.Name && (caller.Field == fieldName || caller.Field == jsonTag) {
							// Modify the field type to use the parent interface type
							field.Type = &ast.Ident{Name: caller.ParentRef}
						}
					}

					// Add the field
					newFields = append(newFields, field)
				}
				structType.Fields.List = newFields
			}

			newSpecs = append(newSpecs, typeSpec)
		}

		if len(newSpecs) > 0 {
			genDecl.Specs = newSpecs
			newFile.Decls = append(newFile.Decls, genDecl)
		}
	}

	// Format the file
	var buf bytes.Buffer
	if err := format.Node(&buf, fset, newFile); err != nil {
		return errors.Errorf("formatting new file: %w", err)
	}

	// Write the file
	outputPath := filepath.Join(cg.outputDir, "model_enhanced.gen.go")
	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return errors.Errorf("writing enhanced model file: %w", err)
	}

	return nil
}

// sanitizeIdentifier converts a string to a valid Go identifier
func sanitizeIdentifier(s string) string {
	// Replace non-alphanumeric characters with underscore
	var result strings.Builder
	for _, r := range s {
		if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' {
			result.WriteRune(r)
		} else {
			result.WriteRune('_')
		}
	}

	// Ensure it starts with a letter
	str := result.String()
	if len(str) == 0 || !unicode.IsLetter(rune(str[0])) {
		return "X" + str
	}

	return str
}

// camelCase converts a string to camelCase
func camelCase(s string) string {
	if s == "" {
		return ""
	}

	// Convert first letter to lowercase
	runes := []rune(s)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}
