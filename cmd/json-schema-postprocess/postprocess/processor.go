package postprocess

import (
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

// Processor coordinates the schema analysis and code generation
type Processor struct {
	SchemaPath    string
	ModelPath     string
	OutputDirPath string
}

// NewProcessor creates a new processor
func NewProcessor(schemaPath, modelPath, outputDirPath string) *Processor {
	return &Processor{
		SchemaPath:    schemaPath,
		ModelPath:     modelPath,
		OutputDirPath: outputDirPath,
	}
}

// Process performs the entire postprocessing workflow
func (p *Processor) Process() error {
	// Step 1: Analyze the schema
	analyzer, err := NewSchemaAnalyzer(p.SchemaPath)
	if err != nil {
		return fmt.Errorf("creating schema analyzer: %w", err)
	}

	results, err := analyzer.Analyze()
	if err != nil {
		return fmt.Errorf("analyzing schema: %w", err)
	}

	// Step 2: Generate the output file
	outputFilePath := filepath.Join(p.OutputDirPath, "schema_fixes.gen.go")
	generator := NewCodeGenerator(p.ModelPath, outputFilePath, results)
	if err := generator.Generate(); err != nil {
		return fmt.Errorf("generating code: %w", err)
	}

	// Step 3: Generate the unmarshal overrides
	overridePath := filepath.Join(p.OutputDirPath, "schema_unmarshal.gen.go")
	if err := p.generateUnmarshalOverrides(overridePath, results); err != nil {
		return fmt.Errorf("generating unmarshal overrides: %w", err)
	}

	return nil
}

// generateUnmarshalOverrides creates a file with overrides for the UnmarshalJSON functions
func (p *Processor) generateUnmarshalOverrides(outputPath string, results *SchemaResults) error {
	// Parse the model file to get its package name
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, p.ModelPath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("parsing model file: %w", err)
	}

	packageName := node.Name.Name

	// Generate unmarshal override functions for parent callers
	var overrideCodes []string

	// Create a generator to help generate the override code
	generator := NewCodeGenerator(p.ModelPath, outputPath, results)

	for _, callerInfo := range results.ParentCallers {
		code, err := generator.generateUnmarshalOverride(callerInfo)
		if err != nil {
			return fmt.Errorf("generating unmarshal override for %s: %w", callerInfo.Name, err)
		}

		if code != "" {
			overrideCodes = append(overrideCodes, code)
		}
	}

	// If no overrides were generated, skip file creation
	if len(overrideCodes) == 0 {
		return nil
	}

	// Assemble the generated code
	outputCode := fmt.Sprintf("// Code generated by json-schema-postprocess, DO NOT EDIT.\n\n")
	outputCode += fmt.Sprintf("package %s\n\n", packageName)
	outputCode += "import (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\n"

	// Add all override functions
	outputCode += strings.Join(overrideCodes, "\n\n")

	// Format the generated code
	formattedBytes, err := format.Source([]byte(outputCode))
	if err != nil {
		return fmt.Errorf("formatting unmarshal overrides code: %w", err)
	}

	// Create output directory if it doesn't exist
	outputDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("creating output directory: %w", err)
	}

	// Write the generated code to the output file
	if err := os.WriteFile(outputPath, formattedBytes, 0644); err != nil {
		return fmt.Errorf("writing unmarshal overrides file: %w", err)
	}

	return nil
}
