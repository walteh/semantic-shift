package postprocess

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"unicode"
)

// CodeGenerator is responsible for generating updated Go code
// based on the schema analysis results
type CodeGenerator struct {
	modelFile string
	outputDir string
	results   *SchemaResults

	// Track which functions we've already generated to avoid duplicates
	generatedMarshalFuncs   map[string]bool
	generatedUnmarshalFuncs map[string]bool
}

// NewCodeGenerator creates a new code generator
func NewCodeGenerator(modelFile, outputDir string, results *SchemaResults) *CodeGenerator {
	return &CodeGenerator{
		modelFile:               modelFile,
		outputDir:               outputDir,
		results:                 results,
		generatedMarshalFuncs:   make(map[string]bool),
		generatedUnmarshalFuncs: make(map[string]bool),
	}
}

// Generate performs the code generation
func (cg *CodeGenerator) Generate() error {
	// Generate the enhanced model code
	if err := cg.generateEnhancedModel(); err != nil {
		return fmt.Errorf("generating enhanced model: %w", err)
	}

	// Generate additional fixes
	if err := cg.generateFixes(); err != nil {
		return fmt.Errorf("generating fixes: %w", err)
	}

	// Generate unmarshal overrides
	if err := cg.generateUnmarshalOverrides(); err != nil {
		return fmt.Errorf("generating unmarshal overrides: %w", err)
	}

	return nil
}

// generateEnhancedModel creates an enhanced version of the original model code
func (cg *CodeGenerator) generateEnhancedModel() error {
	// Parse the original model file
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, cg.modelFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("parsing model file: %w", err)
	}

	// Create a new file with the same package name and imports
	newFile := &ast.File{
		Name:    node.Name,
		Decls:   make([]ast.Decl, 0),
		Imports: node.Imports,
		Doc:     &ast.CommentGroup{List: []*ast.Comment{{Text: "// Code generated by json-schema-postprocess. DO NOT EDIT."}}},
	}

	// Copy over all declarations except implementation methods
	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		// Skip implementation methods
		if genDecl.Tok == token.TYPE {
			newSpecs := make([]ast.Spec, 0)
			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				// Skip interface types ending with "Elem" or "Value"
				if strings.HasSuffix(typeSpec.Name.Name, "Elem") || strings.HasSuffix(typeSpec.Name.Name, "Value") {
					continue
				}

				// If it's a struct type, we need to modify its fields
				if structType, ok := typeSpec.Type.(*ast.StructType); ok {
					newFields := make([]*ast.Field, 0)
					for _, field := range structType.Fields.List {
						// Skip constant fields from child structs
						if len(field.Names) > 0 {
							fieldName := field.Names[0].Name
							if cg.results.ConstantFieldNames[typeSpec.Name.Name] == fieldName {
								continue
							}
						}

						// Check if this field is an array type that needs to be updated
						if arrayType, ok := field.Type.(*ast.ArrayType); ok {
							// Get the field name
							if len(field.Names) > 0 {
								fieldName := field.Names[0].Name
								// Check if this struct has any array parent callers
								if callerInfo, ok := cg.results.ArrayParentCallers[typeSpec.Name.Name+"."+fieldName]; ok {
									// Update the array type based on the parent reference
									if callerInfo.ParentRef != "" {
										// Handle nested arrays
										if nestedArray, ok := arrayType.Elt.(*ast.ArrayType); ok {
											// For nested arrays, we want to use the parent type
											nestedArray.Elt = &ast.Ident{Name: callerInfo.ParentNames[0]}
										} else {
											// For single arrays, replace the element type with the parent type
											arrayType.Elt = &ast.Ident{Name: callerInfo.ParentNames[0]}
										}
									}
								}
							}
						}

						// Check if this field has a tag that references a parent type
						if field.Tag != nil {
							tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
							if jsonTag := tag.Get("json"); jsonTag != "" {
								jsonName := strings.Split(jsonTag, ",")[0]
								// Check if this field references a parent type
								if callerInfo, ok := cg.results.DirectParentCallers[typeSpec.Name.Name+"."+jsonName]; ok {
									// Update the field type to use the parent type
									if callerInfo.ParentRef != "" {
										field.Type = &ast.Ident{Name: callerInfo.ParentNames[0]}
									}
								}
							}
						}

						newFields = append(newFields, field)
					}
					structType.Fields.List = newFields
				}

				newSpecs = append(newSpecs, spec)
			}
			genDecl.Specs = newSpecs
		}

		newFile.Decls = append(newFile.Decls, genDecl)
	}

	// Format the file
	var buf bytes.Buffer
	if err := format.Node(&buf, fset, newFile); err != nil {
		return fmt.Errorf("formatting new file: %w", err)
	}

	// Write the file
	outputPath := filepath.Join(cg.outputDir, "model_enhanced.gen.go")
	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("writing new file: %w", err)
	}

	return nil
}

func (cg *CodeGenerator) writeImplementationMethods(code *strings.Builder, parentName string, info ParentInfo, generatedMethods map[string]bool) error {
	for _, childName := range info.Children {
		methodKey := fmt.Sprintf("%s_%s", childName, parentName)
		if generatedMethods[methodKey] {
			continue
		}
		generatedMethods[methodKey] = true

		// Add the interface implementation method
		code.WriteString(fmt.Sprintf("func (me *%s) is%s()", childName, parentName))
		code.WriteString(strings.Repeat(" ", 40-len(childName)-len(parentName)))
		code.WriteString("{}\n")

		// Add constant field implementation if present
		if info.ConstField != "" {
			constFieldName := strings.Title(info.ConstField)
			// Get the constant value for this child
			constValue := ""
			for child, value := range info.ConstValues {
				if child == childName {
					constValue = value
					break
				}
			}
			if constValue != "" {
				sanitizedValue := sanitizeIdentifier(constValue)
				constName := fmt.Sprintf("%sType%s", parentName, strings.Title(sanitizedValue))
				code.WriteString(fmt.Sprintf("func (me *%s) %s() %sType", childName, constFieldName, parentName))
				code.WriteString(strings.Repeat(" ", 40-len(childName)-len(constFieldName)-len(parentName)))
				code.WriteString(fmt.Sprintf("{ return %s }\n", constName))
			}
		}
	}
	return nil
}

func (cg *CodeGenerator) writeEnhancedInterface(code *strings.Builder, parentName string, info ParentInfo) error {
	// Write the interface declaration
	code.WriteString(fmt.Sprintf("type %s interface {\n", parentName))
	code.WriteString(fmt.Sprintf("\tis%s()\n", parentName))

	// Add constant field method if present
	if info.ConstField != "" {
		constFieldName := strings.Title(info.ConstField)
		code.WriteString(fmt.Sprintf("\t%s() %sType\n", constFieldName, parentName))
	}

	code.WriteString("}\n\n")

	// Add slice and map types
	code.WriteString(fmt.Sprintf("type %sSlice []%s\n", parentName, parentName))
	code.WriteString(fmt.Sprintf("type %sMap map[string]%s\n\n", parentName, parentName))

	return nil
}

func (cg *CodeGenerator) replaceArrayTypes(line string) string {
	for parentName := range cg.results.Parents {
		// Replace array element types with proper slice types
		oldType := fmt.Sprintf("[]%sElem", parentName)
		newType := fmt.Sprintf("%sSlice", parentName)
		line = strings.ReplaceAll(line, oldType, newType)
	}
	return line
}

func isInterfaceDecl(line string) bool {
	line = strings.TrimSpace(line)
	return strings.HasSuffix(line, "interface{}")
}

func extractTypeName(line string) string {
	line = strings.TrimSpace(line)
	parts := strings.Fields(line)
	if len(parts) >= 2 {
		return parts[1]
	}
	return ""
}

func containsArrayType(line string) bool {
	return strings.Contains(line, "[]") && strings.Contains(line, "Elem")
}

// Helper function to check if a slice contains a string
func contains(slice []string, str string) bool {
	for _, s := range slice {
		if s == str {
			return true
		}
	}
	return false
}

// generateFixes generates additional type definitions and helper functions
func (cg *CodeGenerator) generateFixes() error {
	var code strings.Builder

	// Add package and imports
	code.WriteString("// Code generated by json-schema-postprocess, DO NOT EDIT.\n\n")
	code.WriteString("package color\n\n")
	code.WriteString("import (\n")
	code.WriteString("\t\"encoding/json\"\n")
	code.WriteString("\t\"fmt\"\n")
	code.WriteString(")\n\n")

	// Generate model types and constants for parents with constant fields
	for parentName := range cg.results.Parents {
		if cg.results.Parents[parentName].ConstField == "" {
			continue
		}

		// Generate model type
		code.WriteString(fmt.Sprintf("type %sType string\n\n", parentName))
		code.WriteString("const (\n")

		// Add constants for each child's constant value
		for _, constValue := range cg.results.Parents[parentName].ConstValues {
			// Sanitize const value for use as an identifier
			sanitizedValue := sanitizeIdentifier(constValue)
			constName := fmt.Sprintf("%sType%s", parentName, strings.Title(sanitizedValue))
			code.WriteString(fmt.Sprintf("\t%s %sType = \"%s\"\n", constName, parentName, constValue))
		}
		code.WriteString(")\n\n")
	}

	// Generate parse functions for each parent type
	for parentName := range cg.results.Parents {
		if err := cg.writeParseFunc(&code, parentName, cg.results.Parents[parentName]); err != nil {
			return fmt.Errorf("writing parse function for %s: %w", parentName, err)
		}
	}

	// Format the code
	formattedBytes, err := format.Source([]byte(code.String()))
	if err != nil {
		return fmt.Errorf("formatting code: %w", err)
	}

	// Write to file
	outputPath := filepath.Join(cg.outputDir, "model_fixes.gen.go")
	if err := os.WriteFile(outputPath, formattedBytes, 0644); err != nil {
		return fmt.Errorf("writing fixes file: %w", err)
	}

	return nil
}

// writeParseFunc writes the parse function for a parent type
func (cg *CodeGenerator) writeParseFunc(code *strings.Builder, parentName string, parentInfo ParentInfo) error {
	funcName := fmt.Sprintf("parseUnknown%s", parentName)
	code.WriteString(fmt.Sprintf("func %s(b interface{}) (%s, error) {\n", funcName, parentName))
	code.WriteString("\tstr, err := json.Marshal(b)\n")
	code.WriteString("\tif err != nil {\n")
	code.WriteString("\t\treturn nil, err\n")
	code.WriteString("\t}\n\n")

	// If we have a constant field, use it to determine which child to parse
	if parentInfo.ConstField != "" {
		constFieldName := strings.Title(parentInfo.ConstField)
		code.WriteString("\ttype Plain struct {\n")
		code.WriteString(fmt.Sprintf("\t\t%s %sType `json:\"%s\" yaml:\"%s\" mapstructure:\"%s\"`\n",
			constFieldName, parentName, parentInfo.ConstField, parentInfo.ConstField, parentInfo.ConstField))
		code.WriteString("\t}\n")
		code.WriteString("\tvar plain Plain\n")
		code.WriteString("\tif err := json.Unmarshal(str, &plain); err != nil {\n")
		code.WriteString("\t\treturn nil, err\n")
		code.WriteString("\t}\n\n")
		code.WriteString(fmt.Sprintf("\tswitch plain.%s {\n", constFieldName))

		// Add a case for each child type
		for childName, constValue := range parentInfo.ConstValues {
			// Sanitize const value for use as an identifier
			sanitizedValue := sanitizeIdentifier(constValue)
			constName := fmt.Sprintf("%sType%s", parentName, strings.Title(sanitizedValue))
			code.WriteString(fmt.Sprintf("\tcase %s:\n", constName))
			code.WriteString(fmt.Sprintf("\t\tvar %s %s\n", strings.ToLower(childName), childName))
			code.WriteString(fmt.Sprintf("\t\terr = json.Unmarshal(str, &%s)\n", strings.ToLower(childName)))
			code.WriteString(fmt.Sprintf("\t\treturn &%s, err\n", strings.ToLower(childName)))
		}

		code.WriteString("\tdefault:\n")
		code.WriteString(fmt.Sprintf("\t\treturn nil, fmt.Errorf(\"invalid %s: %%s\", plain.%s)\n",
			strings.ToLower(parentInfo.ConstField), constFieldName))
		code.WriteString("\t}\n")
	} else {
		// Without a constant field, try each child type until one works
		code.WriteString("\topts := []" + parentName + "{\n")
		for _, childName := range parentInfo.Children {
			code.WriteString(fmt.Sprintf("\t\t&%s{},\n", childName))
		}
		code.WriteString("\t}\n\n")
		code.WriteString("\tfor _, opt := range opts {\n")
		code.WriteString("\t\terr = json.Unmarshal(str, opt)\n")
		code.WriteString("\t\tif err == nil {\n")
		code.WriteString("\t\t\treturn opt, nil\n")
		code.WriteString("\t\t}\n")
		code.WriteString("\t}\n\n")
		code.WriteString(fmt.Sprintf("\treturn nil, fmt.Errorf(\"invalid %s\")\n", strings.ToLower(parentName)))
	}

	code.WriteString("}\n\n")
	return nil
}

// generateUnmarshalOverrides generates the unmarshal override functions
func (cg *CodeGenerator) generateUnmarshalOverrides() error {
	var code strings.Builder

	// Add package and imports
	code.WriteString("// Code generated by json-schema-postprocess, DO NOT EDIT.\n\n")
	code.WriteString("package color\n\n")
	code.WriteString("import (\n")
	code.WriteString("\t\"encoding/json\"\n")
	code.WriteString("\t\"fmt\"\n")
	code.WriteString(")\n\n")

	// Generate marshal functions for children with constant fields
	for _, parentInfo := range cg.results.Parents {
		if parentInfo.ConstField == "" {
			continue
		}

		constFieldName := strings.Title(parentInfo.ConstField)
		for _, childName := range parentInfo.Children {
			if err := cg.writeMarshalFunc(&code, childName, parentInfo, constFieldName); err != nil {
				return fmt.Errorf("writing marshal function for %s: %w", childName, err)
			}
		}
	}

	// Generate unmarshal overrides for parent callers
	for _, callerInfo := range cg.results.ParentCallers {
		if err := cg.writeUnmarshalOverride(&code, callerInfo); err != nil {
			return fmt.Errorf("writing unmarshal override for %s: %w", callerInfo.Name, err)
		}
	}

	// Format the code
	formattedBytes, err := format.Source([]byte(code.String()))
	if err != nil {
		return fmt.Errorf("formatting code: %w", err)
	}

	// Write to file
	outputPath := filepath.Join(cg.outputDir, "model_unmarshal.gen.go")
	if err := os.WriteFile(outputPath, formattedBytes, 0644); err != nil {
		return fmt.Errorf("writing unmarshal file: %w", err)
	}

	return nil
}

// writeMarshalFunc writes the marshal function for a child type with a constant field
func (cg *CodeGenerator) writeMarshalFunc(code *strings.Builder, childName string, parentInfo ParentInfo, constFieldName string) error {
	// Skip if we've already written this function
	if _, ok := cg.generatedMarshalFuncs[childName]; ok {
		return nil
	}
	cg.generatedMarshalFuncs[childName] = true

	code.WriteString(fmt.Sprintf("func (j %s) MarshalJSON() ([]byte, error) {\n", childName))
	code.WriteString("\t// we need to add the constant field to the output\n")
	code.WriteString(fmt.Sprintf("\ttype Plain %s\n", childName))
	code.WriteString("\tmyMarshal := struct {\n")
	code.WriteString(fmt.Sprintf("\t\t%s %sType `json:\"%s\" yaml:\"%s\" mapstructure:\"%s\"`\n",
		constFieldName, parentInfo.Name, parentInfo.ConstField, parentInfo.ConstField, parentInfo.ConstField))
	code.WriteString("\t\tPlain\n")
	code.WriteString("\t}{\n")
	code.WriteString(fmt.Sprintf("\t\t%s: j.%s(),\n", constFieldName, constFieldName))
	code.WriteString("\t\tPlain: Plain(j),\n")
	code.WriteString("\t}\n")
	code.WriteString("\treturn json.Marshal(myMarshal)\n")
	code.WriteString("}\n\n")

	return nil
}

// writeUnmarshalOverride writes the unmarshal override for a parent caller
func (cg *CodeGenerator) writeUnmarshalOverride(code *strings.Builder, callerInfo ParentCallerInfo) error {
	// Skip if we've already written this function
	if _, ok := cg.generatedUnmarshalFuncs[callerInfo.Name]; ok {
		return nil
	}
	cg.generatedUnmarshalFuncs[callerInfo.Name] = true

	// Generate UnmarshalJSON function signature
	code.WriteString(fmt.Sprintf("func (j *%s) UnmarshalJSON(b []byte) error {\n", callerInfo.Name))
	code.WriteString("\tvar raw map[string]interface{}\n")
	code.WriteString("\tif err := json.Unmarshal(b, &raw); err != nil {\n")
	code.WriteString("\t\treturn err\n")
	code.WriteString("\t}\n")

	// Check required fields
	if callerInfo.IsRequired {
		code.WriteString(fmt.Sprintf("\tif _, ok := raw[\"%s\"]; raw != nil && !ok {\n", callerInfo.Field))
		code.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"field %s in %s: required\")\n", callerInfo.Field, callerInfo.Name))
		code.WriteString("\t}\n")
	}

	// Unmarshal the base structure
	code.WriteString("\ttype Plain " + callerInfo.Name + "\n")
	code.WriteString("\tvar plain Plain\n")
	code.WriteString("\tif err := json.Unmarshal(b, &plain); err != nil {\n")
	code.WriteString("\t\treturn err\n")
	code.WriteString("\t}\n\n")

	// Parse the parent field using the appropriate parse function
	parentField := callerInfo.Field
	parentType := callerInfo.ParentRef

	if callerInfo.IsArray {
		// Handle array field
		code.WriteString(fmt.Sprintf("\t// Process array of %s objects\n", parentType))
		code.WriteString(fmt.Sprintf("\tif raw[\"%s\"] != nil {\n", parentField))
		code.WriteString(fmt.Sprintf("\t\tarr, ok := raw[\"%s\"].([]interface{})\n", parentField))
		code.WriteString("\t\tif ok {\n")
		code.WriteString(fmt.Sprintf("\t\t\tresult := make([]%s, len(arr))\n", parentType))
		code.WriteString("\t\t\tfor i, item := range arr {\n")
		code.WriteString(fmt.Sprintf("\t\t\t\tparsed, err := parseUnknown%s(item)\n", parentType))
		code.WriteString("\t\t\t\tif err != nil {\n")
		code.WriteString(fmt.Sprintf("\t\t\t\t\treturn fmt.Errorf(\"parsing item %%d in %s: %%w\", i, err)\n", parentField))
		code.WriteString("\t\t\t\t}\n")
		code.WriteString("\t\t\t\tresult[i] = parsed\n")
		code.WriteString("\t\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\t\tplain.%s = result\n", strings.Title(parentField)))
		code.WriteString("\t\t}\n")
		code.WriteString("\t}\n")
	} else {
		// Handle direct field
		code.WriteString(fmt.Sprintf("\t// Process %s object\n", parentType))
		code.WriteString(fmt.Sprintf("\tif raw[\"%s\"] != nil {\n", parentField))
		code.WriteString(fmt.Sprintf("\t\tparsed, err := parseUnknown%s(raw[\"%s\"])\n", parentType, parentField))
		code.WriteString("\t\tif err != nil {\n")
		code.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"parsing %s: %%w\", err)\n", parentField))
		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tplain.%s = parsed\n", strings.Title(parentField)))
		code.WriteString("\t}\n")
	}

	// Assign the result back to the original structure
	code.WriteString("\n\t*j = " + callerInfo.Name + "(plain)\n")
	code.WriteString("\treturn nil\n")
	code.WriteString("}\n\n")

	return nil
}

// sanitizeIdentifier makes sure a string can be used as part of a Go identifier
func sanitizeIdentifier(s string) string {
	// Replace dashes and other non-alphanumeric chars with underscores
	result := strings.Map(func(r rune) rune {
		if r == '-' || r == ' ' || r == '.' || !unicode.IsLetter(r) && !unicode.IsNumber(r) {
			return '_'
		}
		return r
	}, s)

	// If it starts with a number, prefix with underscore
	if len(result) > 0 && unicode.IsNumber(rune(result[0])) {
		result = "_" + result
	}

	return result
}

type parentInfo struct {
	ParentStruct string
	FieldName    string
	JsonName     string
}
